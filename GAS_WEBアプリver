/**
 * パーソナルジム予約システム - Google Apps Script
 *
 * 機能:
 * - LINEからのメッセージに応答して予約フォームURL、予約一覧、ヘルプを表示
 * - Webアプリで会員登録と予約フォームを提供
 * - 予約可能な日時をカレンダー形式で表示 (60分間隔)
 * - 予約作成、確認、キャンセル機能
 * - GoogleスプレッドシートとGoogleカレンダーとの連携
 * - 予約前日のリマインドメッセージ送信
 */

// ----------------------------------------
// 定数と設定
// ----------------------------------------

// ▼▼▼ 環境に合わせて設定してください ▼▼▼
const LINE_ACCESS_TOKEN = PropertiesService.getScriptProperties().getProperty('LINE_ACCESS_TOKEN') || 'UYCsmsIdqFkjEZ5PwmZXAU4DbbCIktaTlernaiTx89sr0bngauN6mv+nN1kTSr4dsg8ip4nhX9jHVupm+ddVvrvNkJXxxLGdlUCuLVcr3TnBCNIVHaGWFahME9JH0Qz2ewRcMaK1CYiCZqf7m6y8KQdB04t89/1O/w1cDnyilFU='; // LINE Messaging APIのアクセストークン　【編集箇所】
const CALENDAR_ID = PropertiesService.getScriptProperties().getProperty('CALENDAR_ID') || 'c_9d24918fa9b40d73dd51c600630ff38b2a96508a8bf5bb25029a89c91947a105@group.calendar.google.com'; // 予約管理用GoogleカレンダーID　　【編集箇所】
const SPREADSHEET_ID = PropertiesService.getScriptProperties().getProperty('SPREADSHEET_ID') || '1T14D5L9_o1qq41nING8eBS8CU8dH0PV7ZDvl2ZQxaic'; // データベース用スプレッドシートID　　【編集箇所】
// ▲▲▲ 環境に合わせて設定してください ▲▲▲

// シート名
const SHEET_NAMES = {
  USERS: 'ユーザー情報',
  RESERVATIONS: '予約情報',
  SETTINGS: '設定'
};

// 予約設定　【編集箇所】
const BUSINESS_HOURS = {
  START: 10, // 営業開始時間 (9:00)
  END: 22,  // 営業終了時間 (21:00)
  MAX_SLOTS: 1, // 同時刻の最大予約数（パーソナルなので1）
  MAX_USER_RESERVATIONS: 10, // 1ユーザーあたりの最大予約数
  TIME_INTERVAL: 30 // 予約可能な時間間隔（分）- 60分固定
};

// パーソナルジムの固定設定　【編集箇所】
const SESSION_DURATION = 60; // セッション時間は常に60分

// 予約可能日数（今日から何日先まで予約可能か）　【編集箇所】
const DAYS_AHEAD = 30;

// 予約可能開始日（今日から何日後から予約可能か）　【編集箇所】
const MIN_DAYS_AHEAD = 2;

// 定休日の設定（0:日曜, 1:月曜, 2:火曜, 3:水曜, 4:木曜, 5:金曜, 6:土曜）　【編集箇所】
const CLOSED_DAYS = []; // 日曜日が定休日

// ----------------------------------------
// Webhook (LINEからのリクエスト受信)
// ----------------------------------------

/**
 * LINE Messaging APIからのPOSTリクエストを処理する
 * @param {object} e - イベントオブジェクト
 * @return {object} - ContentService TextOutput
 */
function doPost(e) {
  console.log('doPost関数が呼び出されました');
  try {
    // リクエストボディの存在チェック
    if (!e || !e.postData || !e.postData.contents) {
      console.error('無効なリクエスト: postDataまたはcontentsがありません');
      return createJsonResponse({ status: 'error', message: 'Invalid request: No postData or contents' });
    }

    const contents = JSON.parse(e.postData.contents);

    // イベント配列の存在チェック
    if (!contents.events || !Array.isArray(contents.events)) {
      console.error('無効なリクエスト: events配列がありません');
      return createJsonResponse({ status: 'error', message: 'Invalid request: No events array' });
    }

    // イベント情報をキャッシュに保存（Reply APIでユーザーIDを取得するために使用）
    try {
      const cache = CacheService.getScriptCache();
      cache.put('current_line_events', JSON.stringify(contents.events), 600); // 10分間有効
      console.log('イベント情報をキャッシュに保存しました');
    } catch (cacheError) {
      console.error('イベント情報のキャッシュに失敗しました:', cacheError);
      // キャッシュに失敗してもメイン処理は続行
    }

    // 各イベントを処理
    contents.events.forEach(event => {
      if (!event || !event.source || !event.source.userId) {
        console.warn('Skipping event due to missing source or userId:', JSON.stringify(event));
        return; // ユーザーIDがないイベントはスキップ
      }

      // ユーザーIDと一時トークンのマッピングを作成
      if (event.source.userId) {
        try {
          // ユーザーが操作した直後なので、このタイミングでトークンを事前生成しておく
          const token = generateTokenForUser(event.source.userId);
          console.log(`ユーザー ${event.source.userId} の一時トークン生成: ${token}`);
        } catch (tokenError) {
          console.error('トークン生成エラー:', tokenError);
          // トークン生成に失敗してもメイン処理は続行
        }
      }

      switch (event.type) {
        case 'message':
          if (event.message && event.message.type === 'text') {
            handleUserMessage(event);
          }
          break;
        case 'postback':
          handlePostback(event);
          break;
        case 'follow':
          handleFollow(event);
          break;
        default:
          console.log('未対応のイベントタイプ:', event.type);
      }
    });

    // 正常終了
    return createJsonResponse({ status: 'success' });

  } catch (error) {
    console.error('doPostでエラーが発生しました:', error, error.stack);
    // LINEプラットフォームへのエラー応答
    return createJsonResponse({ status: 'error', message: 'Internal Server Error: ' + error.message });
  }
}

/**
 * JSONレスポンスを生成するヘルパー関数
 * @param {object} obj - レスポンスオブジェクト
 * @return {object} - ContentService TextOutput
 */
function createJsonResponse(obj) {
  return ContentService.createTextOutput(JSON.stringify(obj))
    .setMimeType(ContentService.MimeType.JSON);
}

// ----------------------------------------
// LINEイベントハンドラ
// ----------------------------------------

/**
 * テキストメッセージイベントを処理する
 * @param {object} event - LINEイベントオブジェクト
 */
function handleUserMessage(event) {
  // イベントオブジェクトの存在確認
  if (!event) {
    console.error('handleUserMessage: イベントオブジェクトがありません');
    return;
  }

  // イベントソースの存在確認
  if (!event.source || !event.source.userId) {
    console.error('handleUserMessage: イベントソースまたはuserIdがありません', event);
    return;
  }

  const userId = event.source.userId;
  const userMessage = event.message.text.trim(); 
  const replyToken = event.replyToken; // Reply APIで使用するトークンを取得
  console.log(`メッセージ受信: UserID=${userId}, Message='${userMessage}'`);

  try {
    // メッセージ内容に応じた処理分岐
    if (userMessage === '予約する' || userMessage === '予約') {
      sendReservationButtonMessage(replyToken); // replyTokenを渡すよう変更
    } else if (userMessage === '予約確認') {
      // 予約確認ページURLを送信
      sendReservationCheckUrl(replyToken); // replyTokenを渡すよう変更
    } else if (userMessage === 'ヘルプ') {
      sendHelpMessage(userId, replyToken); // replyTokenを追加
    } else if (userMessage.toLowerCase().startsWith('キャンセル:')) {
      const parts = userMessage.split(':');
      if (parts.length > 1) {
        const reservationId = parts[1].trim();
        if (reservationId) {
          const result = cancelReservation(reservationId, userId);
          sendLineMessage(userId, result.message, replyToken); // replyTokenを追加
        } else {
          sendLineMessage(userId, 'キャンセルする予約IDを指定してください。\n例: キャンセル:12345abc', replyToken); // replyTokenを追加
        }
      } else {
        sendLineMessage(userId, 'キャンセルする予約IDを指定してください。\n例: キャンセル:12345abc', replyToken); // replyTokenを追加
      }
    }
    // 指定されたコマンド以外は何も反応しない
  } catch (error) {
    console.error(`handleUserMessageでエラー UserID=${userId}:`, error, error.stack);
    sendLineMessage(userId, 'エラーが発生しました。しばらくしてからもう一度お試しください。', replyToken); // replyTokenを追加
  }
}

/**
 * 予約ボタン付きメッセージをLINEで送信する関数
 * @param {string} replyToken - Reply APIで使用するトークン
 */
function sendReservationButtonMessage(replyToken) {
  try {
    // replyTokenからユーザーIDを取得するための追加処理
    // 注: 現在のAPI仕様ではReply APIのみでユーザーIDを取得できない場合があります
    const webAppUrl = ScriptApp.getService().getUrl();
    let reservationUrl;
    
    // イベントオブジェクトから取得したuserIdを使用（グローバル変数または前の処理でキャプチャ）
    const currentEvents = CacheService.getScriptCache().get('current_line_events');
    let userId = null;
    
    if (currentEvents) {
      const events = JSON.parse(currentEvents);
      const currentEvent = events.find(e => e.replyToken === replyToken);
      if (currentEvent && currentEvent.source && currentEvent.source.userId) {
        userId = currentEvent.source.userId;
      }
    }
    
    if (userId) {
      // ユーザーIDが取得できた場合は一時トークンを生成
      const token = generateTokenForUser(userId);
      reservationUrl = `${webAppUrl}?token=${encodeURIComponent(token)}`;
    } else {
      // 取得できなかった場合はIDを引数なしでURLを生成
      reservationUrl = webAppUrl;
    }

    // Flex Messageでボタン付きメッセージを作成
    const message = {
      type: 'flex',
      altText: '予約フォームを開く',
      contents: {
        type: 'bubble',
        body: {
          type: 'box',
          layout: 'vertical',
          contents: [
            {
              type: 'text',
              text: '以下のボタンから予約フォームを開いてください。',
              wrap: true,
              margin: 'md'
            }
          ]
        },
        footer: {
          type: 'box',
          layout: 'vertical',
          contents: [
            {
              type: 'button',
              action: {
                type: 'uri',
                label: '予約フォームを開く',
                uri: reservationUrl
              },
              style: 'primary',
              height: 'sm'
            }
          ]
        }
      }
    };

    // Reply APIを使用してFlex Messageを送信
    const url = 'https://api.line.me/v2/bot/message/reply';
    const headers = {
      'Content-Type': 'application/json; charset=UTF-8',
      'Authorization': 'Bearer ' + LINE_ACCESS_TOKEN,
    };
    
    const payload = {
      replyToken: replyToken,
      messages: [message]
    };
    
    const options = {
      method: 'post',
      headers: headers,
      payload: JSON.stringify(payload),
      muteHttpExceptions: true
    };

    const response = UrlFetchApp.fetch(url, options);
    const responseCode = response.getResponseCode();
    
    if (responseCode === 200) {
      console.log('予約ボタン付きメッセージ送信成功:', responseCode);
      return true;
    } else {
      console.error(`予約ボタン付きメッセージ送信失敗: Code=${responseCode}, Body=${response.getContentText()}`);
      // Flex Messageが送信できない場合は、通常のテキストメッセージを代わりに送信
      sendReservationUrl(null, replyToken); // userIdを省略し、replyTokenを渡す
      return false;
    }
    
  } catch (error) {
    console.error(`sendReservationButtonMessageでエラー ReplyToken=${replyToken}:`, error, error.stack);
    // エラー発生時はフォールバックとして通常のテキストメッセージを送信
    sendReservationUrl(null, replyToken); // userIdを省略し、replyTokenを渡す
    return false;
  }
}

/**
 * ポストバックイベントを処理する
 * @param {object} event - LINEイベントオブジェクト
 */
function handlePostback(event) {
  const userId = event.source.userId;
  const data = event.postback.data;
  const replyToken = event.replyToken; // Reply APIで使用するトークンを取得
  console.log(`ポストバック受信: UserID=${userId}, Data='${data}'`);

  try {
    if (!userId) {
      console.error('handlePostback: userIdがありません');
      return;
    }

    // ポストバックデータに応じた処理
    if (data.startsWith('cancel_reservation:')) {
      const reservationId = data.split(':')[1];
      if (reservationId) {
        const result = cancelReservation(reservationId, userId);
        sendLineMessage(userId, result.message, replyToken); // replyTokenを追加
      } else {
        sendLineMessage(userId, 'キャンセル処理でエラーが発生しました。(ID不明)', replyToken); // replyTokenを追加
      }
    }
  } catch (error) {
    console.error(`handlePostbackでエラー UserID=${userId}, Data=${data}:`, error, error.stack);
    sendLineMessage(userId, '処理中にエラーが発生しました。', replyToken); // replyTokenを追加
  }
}

/**
 * フォロー（友達追加）イベントを処理する
 * @param {object} event - LINEイベントオブジェクト
 */
function handleFollow(event) {
  const userId = event.source.userId;
  const replyToken = event.replyToken; // Reply APIで使用するトークンを取得
  console.log(`フォロー受信: UserID=${userId}`);

  try {
    if (!userId) {
      console.error('handleFollow: userIdがありません');
      return;
    }

    // 友達追加時のウェルカムメッセージ
    sendLineMessage(userId,
      'ご登録ありがとうございます！\n\n' +
      'このLINEアカウントでは予約の管理ができます。\n\n' +
      '【使い方】\n' +
      '・「予約する」と送信すると予約フォームのURLが送られます\n' +
      '・「予約確認」と送信すると現在の予約一覧が表示されます\n' +
      '・「ヘルプ」と送信するとヘルプ情報が表示されます',
      replyToken // replyTokenを追加
    );
  } catch (error) {
    console.error(`handleFollowでエラー UserID=${userId}:`, error, error.stack);
  }
}

// ----------------------------------------
// LINEメッセージ送信関数
// ----------------------------------------

/**
* 予約フォームのURLをLINEで送信する関数
* @param {string} userId - 送信先LINEユーザーID (Pushの場合)
* @param {string} replyToken - Reply APIで使用するトークン (Reply時)
*/
function sendReservationUrl(userId, replyToken) {
 try {
   const webAppUrl = ScriptApp.getService().getUrl();
   // ユーザーIDをパラメータとして付与
   // 注: Reply APIの場合はuserIdがnullなので、その場合はURLにuserIdパラメータを含めない
   const reservationUrl = userId ? `${webAppUrl}?userId=${encodeURIComponent(userId)}` : webAppUrl;
   
   const messageText = `【予約フォーム】\n\n以下のURLから予約ができます。\n\n${reservationUrl}`;

   // replyTokenが提供されている場合はReply API、そうでなければPush APIを使用
   if (replyToken) {
     // Reply APIを使用
     const url = 'https://api.line.me/v2/bot/message/reply';
     const headers = {
       'Content-Type': 'application/json; charset=UTF-8',
       'Authorization': 'Bearer ' + LINE_ACCESS_TOKEN,
     };
     const payload = {
       replyToken: replyToken,
       messages: [
         {
           type: 'text',
           text: messageText,
         },
       ],
     };
     const options = {
       method: 'post',
       headers: headers,
       payload: JSON.stringify(payload),
       muteHttpExceptions: true
     };

     const response = UrlFetchApp.fetch(url, options);
     const responseCode = response.getResponseCode();
     
     if (responseCode === 200) {
       console.log('LINEメッセージ送信成功 (Reply):', responseCode);
       return true;
     } else {
       console.error(`LINEメッセージ送信失敗 (Reply): Code=${responseCode}, Body=${response.getContentText()}`);
       return false;
     }
   } else if (userId) {
     // Push APIを使用 (replyTokenがない場合の従来の動作)
     const url = 'https://api.line.me/v2/bot/message/push';
     const headers = {
       'Content-Type': 'application/json; charset=UTF-8',
       'Authorization': 'Bearer ' + LINE_ACCESS_TOKEN,
     };
     const payload = {
       to: userId,
       messages: [
         {
           type: 'text',
           text: messageText,
         },
       ],
     };
     const options = {
       method: 'post',
       headers: headers,
       payload: JSON.stringify(payload),
       muteHttpExceptions: true
     };

     const response = UrlFetchApp.fetch(url, options);
     const responseCode = response.getResponseCode();
     
     if (responseCode === 200) {
       console.log('LINEメッセージ送信成功 (Push):', responseCode);
       return true;
     } else {
       console.error(`LINEメッセージ送信失敗 (Push): Code=${responseCode}, Body=${response.getContentText()}`);
       return false;
     }
   } else {
     console.error('sendReservationUrl: userIdもreplyTokenも指定されていません。');
     return false;
   }
 } catch (error) {
   console.error(`sendReservationUrlでエラー:`, error, error.stack);
   return false;
 }
}

/**
* 予約確認ページのURLをLINEで送信する関数
* @param {string} replyToken - Reply APIで使用するトークン
*/
function sendReservationCheckUrl(replyToken) {
 try {
   // イベントオブジェクトから取得したuserIdを使用
   const currentEvents = CacheService.getScriptCache().get('current_line_events');
   let userId = null;
   
   if (currentEvents) {
     const events = JSON.parse(currentEvents);
     const currentEvent = events.find(e => e.replyToken === replyToken);
     if (currentEvent && currentEvent.source && currentEvent.source.userId) {
       userId = currentEvent.source.userId;
     }
   }
   
   const webAppUrl = ScriptApp.getService().getUrl();
   let reservationCheckUrl = webAppUrl;
   
   if (userId) {
     // ユーザーIDが取得できた場合は一時トークンを生成
     const token = generateTokenForUser(userId);
     reservationCheckUrl = `${webAppUrl}?token=${encodeURIComponent(token)}`;
   }
   
   // Flex Messageでボタン付きメッセージを作成
   const message = {
     type: 'flex',
     altText: '予約確認・キャンセル',
     contents: {
       type: 'bubble',
       body: {
         type: 'box',
         layout: 'vertical',
         contents: [
           {
             type: 'text',
             text: '[予約の確認・キャンセル]タブから操作が行えます。',
             wrap: true,
             margin: 'md'
           }
         ]
       },
       footer: {
         type: 'box',
         layout: 'vertical',
         contents: [
           {
             type: 'button',
             action: {
               type: 'uri',
               label: '予約確認・キャンセル',
               uri: reservationCheckUrl
             },
             style: 'primary',
             height: 'sm'
           }
         ]
       }
     }
   };

   // Reply APIを使用してFlex Messageを送信
   const url = 'https://api.line.me/v2/bot/message/reply';
   const headers = {
     'Content-Type': 'application/json; charset=UTF-8',
     'Authorization': 'Bearer ' + LINE_ACCESS_TOKEN,
   };
   
   const payload = {
     replyToken: replyToken,
     messages: [message]
   };
   
   const options = {
     method: 'post',
     headers: headers,
     payload: JSON.stringify(payload),
     muteHttpExceptions: true
   };

   const response = UrlFetchApp.fetch(url, options);
   const responseCode = response.getResponseCode();
   
   if (responseCode === 200) {
     console.log('予約確認ボタン付きメッセージ送信成功 (Reply):', responseCode);
     return true;
   } else {
     console.error(`予約確認ボタン付きメッセージ送信失敗 (Reply): Code=${responseCode}, Body=${response.getContentText()}`);
     // Flex Messageが送信できない場合は、通常のテキストメッセージを代わりに送信
     const messageText = `【予約確認・キャンセル】\n\n以下のURLから予約の確認・キャンセルができます。\n\n${reservationCheckUrl}`;
     sendLineMessage(null, messageText, replyToken);
     return false;
   }
   
 } catch (error) {
   console.error(`sendReservationCheckUrlでエラー:`, error, error.stack);
   return false;
 }
}

/**
* ヘルプメッセージをLINEで送信する
* @param {string} userId - 送信先LINEユーザーID (Pushの場合) - 今回は使用しない
* @param {string} replyToken - Reply APIで使用するトークン
*/
function sendHelpMessage(userId, replyToken) {
 const closedDayNames = CLOSED_DAYS.map(dayIndex => ["日", "月", "火", "水", "木", "金", "土"][dayIndex]).join('、');
 const messageText = '【ヘルプ】\n\n' +
   '・「予約する」: 予約フォームを開きます\n' +
   '・「予約確認」: 現在の予約を確認します\n' +
   '・「キャンセル:<予約ID>」: 指定したIDの予約をキャンセルします\n\n' +
   `営業時間: ${BUSINESS_HOURS.START}:00～${BUSINESS_HOURS.END}:00\n` +
   `定休日: ${closedDayNames || 'なし'}\n` +
   `予約可能期間: ${MIN_DAYS_AHEAD}日後～${DAYS_AHEAD}日後まで\n` +
   `最大予約数: お一人様${BUSINESS_HOURS.MAX_USER_RESERVATIONS}件まで`;
 
 sendLineMessage(userId, messageText, replyToken);
}

/**
* LINE Messaging APIを使用してテキストメッセージを送信する
* @param {string} userId - 送信先LINEユーザーID (Pushの場合)
* @param {string} messageText - 送信するメッセージ本文
* @param {string} replyToken - Reply APIで使用するトークン (Reply時)
* @return {boolean} - 送信成功時はtrue、失敗時はfalse
*/
function sendLineMessage(userId, messageText, replyToken) {
 if (!messageText) {
   console.error('sendLineMessage: messageTextがありません。');
   return false;
 }

 if (!replyToken && !userId) {
   console.error('sendLineMessage: userIdもreplyTokenも指定されていません。');
   return false;
 }

 if (!LINE_ACCESS_TOKEN || LINE_ACCESS_TOKEN === 'YOUR_LINE_ACCESS_TOKEN') {
   console.error('LINEアクセストークンが設定されていません。スクリプトプロパティを確認してください。');
   return false;
 }

 console.log(`LINEメッセージ送信: ${replyToken ? 'Reply' : 'Push'}, Message='${messageText.substring(0, 50)}...'`); // 長いメッセージは省略してログ表示

 try {
   // replyTokenがある場合はReply API、なければPush APIを使用
   if (replyToken) {
     // Reply APIを使用
     const url = 'https://api.line.me/v2/bot/message/reply';
     const headers = {
       'Content-Type': 'application/json; charset=UTF-8',
       'Authorization': 'Bearer ' + LINE_ACCESS_TOKEN,
     };
     const payload = {
       replyToken: replyToken,
       messages: [
         {
           type: 'text',
           text: messageText,
         },
       ],
     };
     const options = {
       method: 'post',
       headers: headers,
       payload: JSON.stringify(payload),
       muteHttpExceptions: true
     };

     const response = UrlFetchApp.fetch(url, options);
     const responseCode = response.getResponseCode();
     
     if (responseCode === 200) {
       console.log('LINEメッセージ送信成功 (Reply):', responseCode);
       return true;
     } else {
       console.error(`LINEメッセージ送信失敗 (Reply): Code=${responseCode}, Body=${response.getContentText()}`);
       return false;
     }
   } else {
     // Push APIを使用
     const url = 'https://api.line.me/v2/bot/message/push';
     const headers = {
       'Content-Type': 'application/json; charset=UTF-8',
       'Authorization': 'Bearer ' + LINE_ACCESS_TOKEN,
     };
     const payload = {
       to: userId,
       messages: [
         {
           type: 'text',
           text: messageText,
         },
       ],
     };
     const options = {
       method: 'post',
       headers: headers,
       payload: JSON.stringify(payload),
       muteHttpExceptions: true
     };

     const response = UrlFetchApp.fetch(url, options);
     const responseCode = response.getResponseCode();
     
     if (responseCode === 200) {
       console.log('LINEメッセージ送信成功 (Push):', responseCode);
       return true;
     } else {
       console.error(`LINEメッセージ送信失敗 (Push): Code=${responseCode}, Body=${response.getContentText()}`);
       return false;
     }
   }
 } catch (error) {
   console.error('LINEメッセージ送信中に例外発生:', error, error.stack);
   return false;
 }
}

// ----------------------------------------
// Webアプリ (HTMLサービス)
// ----------------------------------------

/**
 * WebアプリへのGETリクエストを処理する
 * @param {object} e - イベントオブジェクト (e.parameter.token または e.parameter.userId を含む)
 * @return {object} - HtmlService Output
 */
function doGet(e) {
  console.log('doGet関数が呼び出されました:', JSON.stringify(e.parameter));
  try {
    let userId = null;
    
    // トークンからユーザーIDを取得
    if (e.parameter.token) {
      userId = getUserIdFromToken(e.parameter.token);
      console.log(`トークンからユーザーID取得: token=${e.parameter.token}, userId=${userId}`);
    } 
    // 直接ユーザーIDが指定されている場合（後方互換性のため）
    else if (e.parameter.userId) {
      userId = e.parameter.userId;
      console.log(`パラメータからユーザーID取得: ${userId}`);
    }

    // userIdがない場合はエラーページを表示
    if (!userId) {
      console.error('doGet: ユーザーIDを取得できませんでした');
      return HtmlService.createHtmlOutput(`
        <p>エラー: アクセス情報の有効期限が切れたか、不正なアクセスです。</p>
        <p>LINEのメニューから「予約する」と送ると、新しいURLが発行されます。</p>
        <p>そちらから再度アクセスしてください。</p>
      `).setTitle('エラー - アクセス期限切れ');
    }

    // システム（スプレッドシート）の初期化を確認・実行
    initializeSystem();

    // ユーザー情報を取得
    let userInfo;
    try {
      userInfo = getUserInfo(userId);
      console.log(`ユーザー情報取得結果: ${userInfo ? 'ユーザーあり' : 'ユーザーなし'}`);
    } catch (userInfoError) {
      console.error(`getUserInfo呼び出しでエラー: ${userInfoError}`);
      userInfo = null;
    }

    if (userInfo) {
      // ユーザー情報があれば予約フォームを表示
      console.log(`ユーザー情報が見つかりました (${userId})。予約フォームを表示します。`);
      return showReservationForm(userId, userInfo, e.parameter.tab || 'new');
    } else {
      // ユーザー情報がなければ会員登録フォームを表示
      console.log(`ユーザー情報が見つかりません (${userId})。会員登録フォームを表示します。`);
      return showRegistrationForm(userId);
    }
  } catch (error) {
    console.error('doGetでエラーが発生しました:', error, error.stack);
    return HtmlService.createHtmlOutput(
      '<p>エラーが発生しました。しばらくしてからもう一度お試しください。</p><p>詳細: ' + error.message + '</p>'
    ).setTitle('エラー');
  }
}

/**
* 会員登録フォームのHTMLページを生成して表示する
* @param {string} userId - LINEユーザーID
* @return {object} - HtmlService Output
*/
function showRegistrationForm(userId) {
 try {
   // HTMLテンプレートを取得
   const template = HtmlService.createTemplateFromFile('registration');
   // テンプレートにユーザーIDを渡す
   template.userId = userId;
   // HTMLを評価してHtmlOutputオブジェクトを生成
   const htmlOutput = template.evaluate();
   htmlOutput.setTitle('会員登録');
   htmlOutput.setXFrameOptionsMode(HtmlService.XFrameOptionsMode.ALLOWALL);
   return htmlOutput;
 } catch (error) {
   console.error('showRegistrationFormでエラー:', error, error.stack);
   return HtmlService.createHtmlOutput('<p>会員登録ページの表示中にエラーが発生しました。</p>');
 }
}

/**
* 予約フォームのHTMLページを生成して表示する
* @param {string} userId - LINEユーザーID
* @param {object} userInfo - ユーザー情報オブジェクト
* @param {string} activeTab - 表示するタブ（'new'または'list'）
* @return {object} - HtmlService Output
*/
function showReservationForm(userId, userInfo, activeTab) {
 try {
   // HTMLテンプレートを取得
   const template = HtmlService.createTemplateFromFile('reservation');

   // テンプレートに変数を渡す
   template.userId = userId;
   template.userName = userInfo.name;
   template.userPhone = userInfo.phone;
   template.activeTab = activeTab;

   // 予約可能な期間を計算
   const today = new Date();
   const startDate = new Date();
   startDate.setDate(today.getDate() + MIN_DAYS_AHEAD);
   const endDate = new Date();
   endDate.setDate(today.getDate() + DAYS_AHEAD);

   // 日付フォーマット
   let startDateStr = formatDate(startDate);
   let endDateStr = formatDate(endDate);

   template.startDate = startDateStr; // YYYY-MM-DD形式
   template.endDate = endDateStr;     // YYYY-MM-DD形式

   // ビジネス設定を渡す
   template.businessHoursJson = JSON.stringify(BUSINESS_HOURS);
   template.closedDaysJson = JSON.stringify(CLOSED_DAYS);
   template.sessionDuration = SESSION_DURATION;
   template.minDaysAhead = MIN_DAYS_AHEAD;
   template.daysAhead = DAYS_AHEAD;

   // HTMLを評価してHtmlOutputオブジェクトを生成
   const htmlOutput = template.evaluate();
   htmlOutput.setTitle('予約フォーム');
   htmlOutput.setXFrameOptionsMode(HtmlService.XFrameOptionsMode.ALLOWALL);
   return htmlOutput;
 } catch (error) {
   console.error('showReservationFormでエラー:', error, error.stack);
   return HtmlService.createHtmlOutput('<p>予約ページの表示中にエラーが発生しました。</p>');
 }
}

// ----------------------------------------
// 日付関連ヘルパー関数
// ----------------------------------------

/**
* 日付オブジェクトをYYYY-MM-DD 形式の文字列にフォーマットする
* @param {Date} date - フォーマットする日付オブジェクト
* @return {string} - フォーマットされた日付文字列
*/
function formatDate(date) {
 if (!date || !(date instanceof Date) || isNaN(date.getTime())) {
   return ''; // 無効な日付の場合は空文字を返す
 }
 try {
   // UTC基準ではなく、スクリプトのタイムゾーン（通常は日本のタイムゾーン）でフォーマット
   return Utilities.formatDate(date, Session.getScriptTimeZone(), 'yyyy-MM-dd');
 } catch (error) {
    console.error('formatDateでエラー:', error);
    // フォールバックとして手動でフォーマット
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    return `${year}-${month}-${day}`;
 }
}

/**
* 日付を「YYYY年MM月DD日（曜日）」形式にフォーマットする関数
* @param {Date} date - フォーマットする日付オブジェクト
* @return {string} - 「YYYY年MM月DD日（曜日）」形式の文字列
*/
function formatDateJapanese(date) {
 if (!date || !(date instanceof Date) || isNaN(date.getTime())) {
   return ''; // 無効な日付の場合は空文字を返す
 }
 
 try {
   const dayNames = ["日", "月", "火", "水", "木", "金", "土"];
   const year = date.getFullYear();
   const month = date.getMonth() + 1;
   const day = date.getDate();
   const dayOfWeek = dayNames[date.getDay()];
   
   return `${year}年${month}月${day}日（${dayOfWeek}）`;
 } catch (error) {
   console.error('formatDateJapaneseでエラー:', error);
   return formatDate(date); // エラーが発生した場合は通常のformatDateにフォールバック
 }
}

// ----------------------------------------
// カレンダー関連関数
// ----------------------------------------

/**
* 指定した日付範囲のカレンダーイベントを取得する
* @param {Date} startDate - 開始日
* @param {Date} endDate - 終了日
* @param {string} calendarId - カレンダーID
* @return {Array} - カレンダーイベントの配列
*/
function getCalendarEvents(startDate, endDate, calendarId) {
 try {
   const calendar = calendarId 
     ? CalendarApp.getCalendarById(calendarId) 
     : CalendarApp.getDefaultCalendar();
   
   if (!calendar) {
     console.error('カレンダーが見つかりません:', calendarId);
     return [];
   }
   
   // 指定した日付範囲のイベントを取得
   const events = calendar.getEvents(startDate, endDate);
   
   // 各イベントの情報を整形
   return events.map(event => {
     const eventStart = event.getStartTime();
     const eventEnd = event.getEndTime();
     const isAllDay = (
       eventStart.getHours() === 0 && 
       eventStart.getMinutes() === 0 && 
       eventEnd.getHours() === 0 && 
       eventEnd.getMinutes() === 0 &&
       (eventEnd.getTime() - eventStart.getTime()) >= 24 * 60 * 60 * 1000
     );
     
     return {
       id: event.getId(),
       title: event.getTitle(),
       startTime: eventStart,
       endTime: eventEnd,
       description: event.getDescription(),
       isAllDay: isAllDay
     };
   });
 } catch (error) {
   console.error('カレンダーイベント取得エラー:', error, error.stack);
   return [];
 }
}

// ----------------------------------------
// ユーザー関連機能
// ----------------------------------------

/**
* ユーザー情報をスプレッドシートから取得する
* @param {string} userId - LINEユーザーID
* @return {object|null} - ユーザー情報オブジェクト、見つからない場合はnull
*/
function getUserInfo(userId) {
 console.log(`getUserInfo呼び出し: User=${userId}`);
 if (!userId) return null;

 try {
   const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
   const sheet = ss.getSheetByName(SHEET_NAMES.USERS);
   if (!sheet) {
     console.error('ユーザー情報シートが見つかりません。');
     initializeSystem(); // シートがなければ初期化を試みる
     return null;
   }
   const data = sheet.getDataRange().getValues();

   // ヘッダー行(0)をスキップし、1行目からループ
   for (let i = 1; i < data.length; i++) {
     if (data[i][0] === userId) { // UID列(0)で比較
       console.log(`ユーザー情報発見: ${userId}`);
       
       // フォーマット関数のエラーを防止するため、日付処理を保護
       let birthdateStr = null;
       if (data[i][5]) {
         try {
           birthdateStr = formatDate(new Date(data[i][5]));
         } catch (e) {
           console.warn(`birthdate フォーマットエラー: ${e.message}`);
           // 手動でフォーマット
           const bdate = new Date(data[i][5]);
           if (!isNaN(bdate.getTime())) {
             birthdateStr = `${bdate.getFullYear()}-${String(bdate.getMonth() + 1).padStart(2, '0')}-${String(bdate.getDate()).padStart(2, '0')}`;
           }
         }
       }
       
       return {
         userId: data[i][0],
         name: data[i][1],
         phone: data[i][2],
         email: data[i][3],
         gender: data[i][4],
         birthdate: birthdateStr, // 日付形式で返す
         referralSource: data[i][7] || "" // 知ったきっかけ（存在しない場合は空文字）
       };
     }
   }
   console.log(`ユーザー情報見つからず: ${userId}`);
   return null;
 } catch (error) {
   console.error('getUserInfoでエラー:', error, error.stack);
   return null;
 }
}


/**
* 新規ユーザーを登録する (クライアントサイドJSから呼び出される)
* @param {object} userData - ユーザー情報 (userId, name, phone, email, gender, birthdate, referralSource)
* @return {object} - { success: boolean, message: string }
*/
function registerUser(userData) {
 console.log('registerUser呼び出し:', JSON.stringify(userData));
 if (!userData || !userData.userId || !userData.name || !userData.phone || !userData.email || !userData.gender || !userData.birthdate) {
   return { success: false, message: '登録情報が不足しています。' };
 }

 const lock = LockService.getScriptLock();
 try {
   lock.waitLock(10000); // 最大10秒待機

   // 既存ユーザーチェック
   if (getUserInfo(userData.userId)) {
     console.log(`ユーザー (${userData.userId}) は既に登録済みです。`);
     // 既存ユーザーの場合は成功として扱い、予約フォームへ遷移させるメッセージを返す
     return { success: true, message: 'ユーザー情報は既に登録されています。予約ページへ進みます。' };
   }

   const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
   const sheet = ss.getSheetByName(SHEET_NAMES.USERS);
   if (!sheet) {
     console.error('ユーザー情報シートが見つかりません。');
     initializeSystem(); // 初期化試行
     // 再度シート取得を試みる
     const newSheet = ss.getSheetByName(SHEET_NAMES.USERS);
     if (!newSheet) {
       return { success: false, message: 'システムエラーが発生しました。(User sheet creation failed)' };
     }
     // 新しいシートを使用する
     const registrationTime = new Date();
     newSheet.appendRow([
       userData.userId,
       userData.name,
       userData.phone,
       userData.email,
       userData.gender,
       new Date(userData.birthdate), // Dateオブジェクトとして保存
       registrationTime,
       userData.referralSource || "" // 知ったきっかけ（空欄の場合は空文字）
     ]);
   } else {
     const registrationTime = new Date();
     // スプレッドシートに追記
     sheet.appendRow([
       userData.userId,
       userData.name,
       userData.phone,
       userData.email,
       userData.gender,
       new Date(userData.birthdate), // Dateオブジェクトとして保存
       registrationTime,
       userData.referralSource || "" // 知ったきっかけ（空欄の場合は空文字）
     ]);
   }

   console.log(`ユーザー登録完了: ${userData.userId}, ${userData.name}, きっかけ: ${userData.referralSource || "未入力"}`);
   return { success: true, message: '会員登録が完了しました。' };

 } catch (error) {
   console.error('registerUserでエラー:', error, error.stack);
   return { success: false, message: 'ユーザー登録中に予期せぬエラーが発生しました。' };
 } finally {
   try {
     if (lock.hasLock()) {
       lock.releaseLock();
     }
   } catch (lockError) {
     console.error('ロック解放エラー:', lockError);
   }
 }
}

// ----------------------------------------
// 予約関連コア機能
// ----------------------------------------

/**
* 新しい予約を作成する (クライアントサイドJSから呼び出される)
* @param {object} reservationData - 予約情報 (userId, date, time, notes)
* @return {object} - { success: boolean, message: string, reservationInfo?: object }
*/
function createReservation(reservationData) {
 console.log('createReservation呼び出し:', JSON.stringify(reservationData));
 const lock = LockService.getScriptLock();
 try {
   lock.waitLock(15000); // 最大15秒待機

   // --- バリデーション ---
   if (!reservationData || !reservationData.userId || !reservationData.date || !reservationData.time) {
     return { success: false, message: '予約情報が不足しています。' };
   }

   // ユーザー情報取得
   const userInfo = getUserInfo(reservationData.userId);
   if (!userInfo) {
     return { success: false, message: 'ユーザー情報が見つかりません。会員登録を完了してください。' };
   }

   // 予約日時パース
   const reservationDateTime = new Date(`${reservationData.date}T${reservationData.time}:00`);
   if (isNaN(reservationDateTime.getTime())) {
     return { success: false, message: '日時の形式が無効です。' };
   }

   // 現在時刻
   const now = new Date();

   // 予約数上限チェック (未来の予約のみカウント)
   const userReservations = getUserReservations(reservationData.userId);
   if (userReservations.length >= BUSINESS_HOURS.MAX_USER_RESERVATIONS) {
     return { success: false, message: `予約数が上限（${BUSINESS_HOURS.MAX_USER_RESERVATIONS}件）に達しています。` };
   }

   // 予約可能期間チェック
   const today = new Date();
   today.setHours(0, 0, 0, 0);
   const minBookableDate = new Date(today);
   minBookableDate.setDate(today.getDate() + MIN_DAYS_AHEAD);
   const maxBookableDate = new Date(today);
   maxBookableDate.setDate(today.getDate() + DAYS_AHEAD);
   maxBookableDate.setHours(23, 59, 59, 999); // 終了日の終わりまで

   if (reservationDateTime < minBookableDate || reservationDateTime > maxBookableDate) {
     return { success: false, message: `予約可能期間（${MIN_DAYS_AHEAD}日後～${DAYS_AHEAD}日後）外です。` };
   }
   
   // 過去日時チェック
   if (reservationDateTime < now) {
     return { success: false, message: '過去の日時を予約することはできません。' };
   }

   // 定休日チェック
   if (CLOSED_DAYS.includes(reservationDateTime.getDay())) {
     return { success: false, message: '選択された日は定休日です。' };
   }

   // 営業時間チェック
   const reservationHour = reservationDateTime.getHours();
   if (reservationHour < BUSINESS_HOURS.START || reservationHour >= BUSINESS_HOURS.END) {
     return { success: false, message: '選択された時間は営業時間外です。' };
   }

   // --- 空き状況再チェック（競合回避）---
   const reservationsSheet = SpreadsheetApp.openById(SPREADSHEET_ID).getSheetByName(SHEET_NAMES.RESERVATIONS);
   if (!reservationsSheet) {
     return { success: false, message: 'システムエラーが発生しました。予約シートが見つかりません。' };
   }
   
   const data = reservationsSheet.getDataRange().getValues();
   let currentReservationsAtTime = 0;
   for (let i = 1; i < data.length; i++) {
     // data[i][6] は予約日時, data[i][10] はキャンセル列
     const existingReservationTime = new Date(data[i][6]);
     const isCancelled = data[i][10]; // キャンセルフラグの値を取得
     if (!isCancelled && 
         existingReservationTime.getFullYear() === reservationDateTime.getFullYear() &&
         existingReservationTime.getMonth() === reservationDateTime.getMonth() &&
         existingReservationTime.getDate() === reservationDateTime.getDate() &&
         existingReservationTime.getHours() === reservationDateTime.getHours() &&
         existingReservationTime.getMinutes() === reservationDateTime.getMinutes()) {
       currentReservationsAtTime++;
     }
   }

   if (currentReservationsAtTime >= BUSINESS_HOURS.MAX_SLOTS) {
     console.warn(`予約競合発生: ${reservationData.date} ${reservationData.time}`);
     return { success: false, message: '申し訳ありません、選択された時間枠は直前に埋まってしまいました。別の日時を選択してください。' };
   }

   // --- 予約処理実行 ---
   // 予約ID生成
   const reservationId = Utilities.formatDate(now, 'GMT+9', 'MMddHHmmss') + Math.random().toString(36).substring(2, 8);
   
   // 固定の情報
   const trainingDescription = "パーソナルトレーニング";
   
   // 予約終了時間を計算
   const endTime = new Date(reservationDateTime.getTime() + SESSION_DURATION * 60 * 1000);
   const creationTime = now;
   
   // スタッフへのメモを取得
   const customerNotes = reservationData.notes || "";
   
   // スプレッドシートに追記
   reservationsSheet.appendRow([
     reservationId,          // 予約ID [0]
     reservationData.userId, // UID [1]
     userInfo.name,          // 氏名 [2]
     userInfo.phone,         // 電話番号 [3]
     "training",             // 固定のトレーニングID [4]
     "none",                 // スタッフID [5]
     reservationDateTime,    // 予約日時 [6]
     endTime,                // 終了時間 [7]
     creationTime,           // 予約作成日時 [8]
     false,                  // リマインド送信済み [9]
     false,                  // キャンセル [10]
     0,                      // 金額（必要に応じて設定） [11]
     trainingDescription,    // 説明テキスト [12]
     SESSION_DURATION,       // トレーニング時間 [13]
     customerNotes           // スタッフへのメモ [14] - 新規追加
   ]);
   console.log(`スプレッドシートに予約追加: ID=${reservationId}, メモ=${customerNotes ? "あり" : "なし"}`);

   // Googleカレンダーに登録
   try {
     const calendar = CalendarApp.getCalendarById(CALENDAR_ID);
     if (calendar) {
       const eventTitle = `${userInfo.name}様 / パーソナルトレーニング`;
       const eventDescription = `予約ID: ${reservationId}\nLINE UID: ${reservationData.userId}\n電話番号: ${userInfo.phone}\n内容: ${trainingDescription}\n\n【スタッフへのメモ】\n${customerNotes || "なし"}`;
       calendar.createEvent(eventTitle, reservationDateTime, endTime, { description: eventDescription });
       console.log(`Googleカレンダーにイベント追加: ${eventTitle}`);
     } else {
       console.error(`カレンダーが見つかりません (ID: ${CALENDAR_ID})`);
     }
   } catch (calendarError) {
     console.error(`カレンダー登録エラー (予約ID: ${reservationId}):`, calendarError, calendarError.stack);
     // カレンダー登録失敗は予約自体は成功とするが、ログには残す
   }

   // LINEで予約完了通知
   /***
   // 以下の予約完了通知はPush APIを使用するため、コメントアウトして実行されないようにします　【編集箇所】
   try {
     const formattedDate = formatDateJapanese(reservationDateTime);
     
     // 予約確定のFlexメッセージ部分
     const flexMessage = {
       type: "flex",
       altText: "予約が確定しました",
       contents: {
         type: "bubble",
         header: {
           type: "box",
           layout: "vertical",
           contents: [
             {
               type: "text",
               text: "予約確定のお知らせ",
               weight: "bold",
               size: "md",
               color: "#FFFFFF"
             }
           ],
           backgroundColor: "#2EB900"
         },
         hero: {
           type: "image",
           url: "https://image.freepik.com/free-photo/weights-exercise-weightlifter-strong-athletic_1139-709.jpg",
           size: "full",
           aspectRatio: "20:13",
           aspectMode: "cover"
         },
         body: {
           type: "box",
           layout: "vertical",
           contents: [
             {
               type: "text",
               text: "ご予約ありがとうございます",
               weight: "bold",
               size: "md",
               wrap: true
             },
             {
               type: "box",
               layout: "vertical",
               margin: "lg",
               spacing: "md",
               contents: [
                 {
                   type: "box",
                   layout: "baseline",
                   spacing: "md",
                   contents: [
                     {
                       type: "text",
                       text: "日時",
                       color: "#aaaaaa",
                       size: "sm",
                       flex: 2
                     },
                     {
                       type: "text",
                       text: `${formattedDate} ${reservationData.time}～${Utilities.formatDate(endTime, 'Asia/Tokyo', 'HH:mm')}`,
                       wrap: true,
                       color: "#666666",
                       size: "sm",
                       flex: 8,
                       weight: "regular"
                     }
                   ]
                 },
                 {
                   type: "box",
                   layout: "baseline",
                   spacing: "md",
                   contents: [
                     {
                       type: "text",
                       text: "内容", 
                       color: "#aaaaaa",
                       size: "sm",
                       flex: 2
                     },
                     {
                       type: "text",
                       text: "パーソナルトレーニング",
                       wrap: true,
                       color: "#666666",
                       size: "sm",
                       flex: 8,
                       weight: "regular"
                     }
                   ]
                 },
                 {
                   type: "box",
                   layout: "baseline",
                   spacing: "md",
                   contents: [
                     {
                       type: "text",
                       text: "予約ID",
                       color: "#aaaaaa",
                       size: "sm",
                       flex: 2
                     },
                     {
                       type: "text",
                       text: reservationId,
                       wrap: true,
                       color: "#666666",
                       size: "sm",
                       flex: 8,
                       weight: "regular"
                     }
                   ]
                 },
                 {
                   type: "box",
                   layout: "baseline",
                   spacing: "md",
                   contents: [
                     {
                       type: "text",
                       text: "メモ",
                       color: "#aaaaaa",
                       size: "sm",
                       flex: 2
                     },
                     {
                       type: "text",
                       text: customerNotes || "なし",
                       wrap: true,
                       color: "#666666",
                       size: "sm",
                       flex: 8,
                       weight: "regular"
                     }
                   ]
                 }
               ]
             }
           ]
         },
         footer: {
           type: "box",
           layout: "vertical",
           spacing: "sm",
           contents: [
             {
               type: "text",
               text: "前日に確認メッセージをお送りします。",
               wrap: true,
               size: "sm"
             },
             {
               type: "text",
               text: "当日は動きやすい服装でお越しください。",
               wrap: true,
               size: "sm"
             }
           ],
           flex: 0
         },
         styles: {
           footer: {
             separator: true
           }
         }
       }
     };
     
     // Flex Messageを送信
     const url = 'https://api.line.me/v2/bot/message/push';
     const headers = {
       'Content-Type': 'application/json; charset=UTF-8',
       'Authorization': 'Bearer ' + LINE_ACCESS_TOKEN,
     };
     const payload = {
       to: reservationData.userId,
       messages: [flexMessage]
     };
     const options = {
       method: 'post',
       headers: headers,
       payload: JSON.stringify(payload),
       muteHttpExceptions: true
     };

     const response = UrlFetchApp.fetch(url, options);
     console.log(`予約完了Flex Message送信: UserID=${reservationData.userId}, ResponseCode=${response.getResponseCode()}`);
     
   } catch (lineError) {
     console.error(`予約完了LINE通知エラー (予約ID: ${reservationId}):`, lineError, lineError.stack);
     // LINE通知失敗も予約自体は成功とする
   }
   ***/

   // 成功レスポンス
   return {
     success: true,
     message: '予約が完了しました。',
     reservationInfo: { // クライアント側での表示用に情報を返す
       id: reservationId,
       date: reservationData.date,
       time: reservationData.time,
       endTime: Utilities.formatDate(endTime, 'Asia/Tokyo', 'HH:mm'),
       description: trainingDescription,
       duration: SESSION_DURATION,
       notes: customerNotes // スタッフへのメモ情報を追加
     }
   };

 } catch (error) {
   console.error('createReservationでエラー:', error, error.stack);
   return { success: false, message: '予約処理中に予期せぬエラーが発生しました。' };
 } finally {
   try {
     if (lock.hasLock()) {
       lock.releaseLock();
     }
   } catch (lockError) {
     console.error('ロック解放エラー:', lockError);
   }
 }
}

/**
* 予約キャンセル完了時のFlexメッセージを生成する関数
* @param {string} reservationId - キャンセルした予約ID
* @param {string} date - 予約日付（YYYY-MM-DD形式）
* @param {string} time - 予約時間（HH:MM形式）
* @param {string} formattedDate - 日本語フォーマット日付（例: 2025年4月15日（火））
* @return {object} - LINE Flex Messageオブジェクト
*/
function createCancellationFlexMessage(reservationId, date, time, formattedDate) {
 // formattedDateが指定されていない場合は日付から生成
 if (!formattedDate) {
   const dateObj = new Date(`${date}T${time}:00`);
   const dayNames = ["日", "月", "火", "水", "木", "金", "土"];
   formattedDate = `${dateObj.getFullYear()}年${dateObj.getMonth() + 1}月${dateObj.getDate()}日（${dayNames[dateObj.getDay()]}）`;
 }

 // キャンセル完了のFlexメッセージ
 const flexMessage = {
   type: "flex",
   altText: "予約キャンセル完了",
   contents: {
     type: "bubble",
     header: {
       type: "box",
       layout: "vertical",
       contents: [
         {
           type: "text",
           text: "予約キャンセル完了",
           weight: "bold",
           size: "md",
           color: "#FFFFFF"
         }
       ],
       backgroundColor: "#333333" // キャンセルなので暗め系
     },
     body: {
       type: "box",
       layout: "vertical",
       contents: [
         {
           type: "text",
           text: "以下の予約のキャンセルが完了しました",
           weight: "bold",
           size: "md",
           wrap: true
         },
         {
           type: "box",
           layout: "vertical",
           margin: "lg",
           spacing: "md",
           contents: [
             {
               type: "box",
               layout: "baseline",
               spacing: "md",
               contents: [
                 {
                   type: "text",
                   text: "日時",
                   color: "#aaaaaa",
                   size: "sm",
                   flex: 2
                 },
                 {
                   type: "text",
                   text: `${formattedDate} ${time}`,
                   wrap: true,
                   color: "#666666",
                   size: "sm",
                   flex: 8,
                   weight: "regular"
                 }
               ]
             },
             {
               type: "box",
               layout: "baseline",
               spacing: "md",
               contents: [
                 {
                   type: "text",
                   text: "内容", 
                   color: "#aaaaaa",
                   size: "sm",
                   flex: 2
                 },
                 {
                   type: "text",
                   text: "パーソナルトレーニング",
                   wrap: true,
                   color: "#666666",
                   size: "sm",
                   flex: 8,
                   weight: "regular"
                 }
               ]
             },
             {
               type: "box",
               layout: "baseline",
               spacing: "md",
               contents: [
                 {
                   type: "text",
                   text: "予約ID",
                   color: "#aaaaaa",
                   size: "sm",
                   flex: 2
                 },
                 {
                   type: "text",
                   text: reservationId,
                   wrap: true,
                   color: "#666666",
                   size: "sm",
                   flex: 8,
                   weight: "regular"
                 }
               ]
             }
           ]
         }
       ]
     },
     footer: {
       type: "box",
       layout: "vertical",
       spacing: "sm",
       contents: [
         {
           type: "text",
           text: "またのご予約をお待ちしております。",
           wrap: true,
           size: "sm"
         },
       ],
       flex: 0
     },
     styles: {
       footer: {
         separator: true
       }
     }
   }
 };
 
 return flexMessage;
}

/**
* 予約をキャンセルする (クライアントサイドJSまたはLINEメッセージから呼び出される)
* @param {string} reservationId - キャンセルする予約ID
* @param {string} userId - 操作を行うユーザーのLINEユーザーID
* @return {object} - { success: boolean, message: string }
*/
function cancelReservation(reservationId, userId) {
 console.log(`cancelReservation呼び出し: ID=${reservationId}, User=${userId}`);
 if (!reservationId || !userId) {
   return { success: false, message: '予約IDまたはユーザーIDが指定されていません。' };
 }

 const lock = LockService.getScriptLock();
 try {
   lock.waitLock(15000); // 最大15秒待機

   const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
   const sheet = ss.getSheetByName(SHEET_NAMES.RESERVATIONS);
   if (!sheet) {
     console.error('予約情報シートが見つかりません。');
     return { success: false, message: 'システムエラーが発生しました。(Sheet not found)' };
   }
   const data = sheet.getDataRange().getValues();
   let reservationFound = false;
   let reservationDetails = {};

   // ヘッダーを除いて検索 (インデックス1から)
   for (let i = 1; i < data.length; i++) {
     // data[i][0]は予約ID, data[i][1]はUID, data[i][10]はキャンセル列
     if (data[i][0] === reservationId) {
       // ユーザーIDが一致するか、または管理者が操作する場合などを考慮（今回はユーザーID一致のみ）
       if (data[i][1] === userId) {
         reservationFound = true;
          // すでにキャンセル済みかチェック
          if (data[i][10] === true) {
            console.log(`予約ID ${reservationId} は既にキャンセルされています。`);
            return { success: false, message: 'この予約は既にキャンセルされています。' };
          }
          // 過去の予約はキャンセルできないようにする（任意）
          const reservationDateTime = new Date(data[i][6]);
          if (reservationDateTime < new Date()) {
            console.log(`過去の予約 (${reservationId}) のキャンセル試行。`);
            return { success: false, message: '過去の予約をキャンセルすることはできません。' };
          }

         // キャンセル処理実行
         sheet.getRange(i + 1, 11).setValue(true); // キャンセル列 (11番目=K列) に true を設定
         sheet.getRange(i + 1, 12).setValue(new Date()); // キャンセル日時列 (12番目=L列) に現在時刻を設定
         console.log(`スプレッドシートで予約キャンセル: ID=${reservationId}`);

         // 予約詳細を保持
         let dateStr;
         try {
           dateStr = formatDate(reservationDateTime);
         } catch (e) {
           dateStr = `${reservationDateTime.getFullYear()}-${String(reservationDateTime.getMonth() + 1).padStart(2, '0')}-${String(reservationDateTime.getDate()).padStart(2, '0')}`;
         }
         
         const timeStr = `${String(reservationDateTime.getHours()).padStart(2, '0')}:${String(reservationDateTime.getMinutes()).padStart(2, '0')}`;
         
         reservationDetails = {
            date: dateStr,
            time: timeStr
         };

         // Googleカレンダーからイベント削除
         try {
           const calendar = CalendarApp.getCalendarById(CALENDAR_ID);
           if (calendar) {
             // イベント検索: タイトルや説明に予約IDが含まれるものを探す
             const events = calendar.getEvents(reservationDateTime, new Date(reservationDateTime.getTime() + 2 * 60 * 60 * 1000), { search: reservationId }); // 予約時刻周辺で検索
             if (events.length > 0) {
               events[0].deleteEvent(); // 最初に見つかったものを削除 (IDで完全一致が望ましい)
               console.log(`Googleカレンダーからイベント削除: ID=${reservationId}`);
             } else {
               console.warn(`カレンダーイベントが見つかりません: ID=${reservationId}`);
             }
           } else {
             console.error(`カレンダーが見つかりません (ID: ${CALENDAR_ID})`);
           }
         } catch (calendarError) {
           console.error(`カレンダー削除エラー (予約ID: ${reservationId}):`, calendarError, calendarError.stack);
           // カレンダー削除失敗はキャンセル自体は成功とする
         }

         /***
         // LINEでキャンセル完了通知（Flexメッセージを使用）- Push APIを使用するため、コメントアウト　【編集箇所】
         try {
           // 日本語フォーマットの日付を生成
           const formattedDate = formatDateJapanese(reservationDateTime);
           
           // Flexメッセージ生成
           const flexMessage = createCancellationFlexMessage(
             reservationId,
             dateStr,
             timeStr,
             formattedDate
           );
           
           // LINE Messaging APIでメッセージ送信
           const url = 'https://api.line.me/v2/bot/message/push';
           const headers = {
             'Content-Type': 'application/json; charset=UTF-8',
             'Authorization': 'Bearer ' + LINE_ACCESS_TOKEN,
           };
           const payload = {
             to: userId,
             messages: [flexMessage]
           };
           const options = {
             method: 'post',
             headers: headers,
             payload: JSON.stringify(payload),
             muteHttpExceptions: true
           };

           const response = UrlFetchApp.fetch(url, options);
           const responseCode = response.getResponseCode();
           console.log(`キャンセル完了Flex Message送信: UserID=${userId}, ResponseCode=${responseCode}`);
           
           // Flexメッセージ送信が失敗した場合のフォールバック（通常のテキストメッセージ）
           if (responseCode !== 200) {
             const message = `【予約キャンセル完了】\n以下の予約がキャンセルされました。\n\n` +
                           `予約ID: ${reservationId}\n` +
                           `日時: ${formattedDate} ${timeStr}`;
             sendLineMessage(userId, message);
           }
         } catch (lineError) {
           console.error(`キャンセル完了LINE通知エラー (予約ID: ${reservationId}):`, lineError, lineError.stack);
           // エラー時のフォールバック（通常のテキストメッセージ）
           try {
             const message = `【予約キャンセル完了】\n以下の予約がキャンセルされました。\n\n` +
                          `予約ID: ${reservationId}\n` +
                          `日時: ${reservationDetails.date} ${reservationDetails.time}`;
             sendLineMessage(userId, message);
           } catch (fallbackError) {
             console.error(`フォールバックメッセージ送信エラー:`, fallbackError);
           }
         }
         ***/

         return { success: true, message: '予約をキャンセルしました。' };
       } else {
         // 予約IDは存在するが、ユーザーIDが一致しない場合
         console.warn(`予約キャンセル権限なし: ID=${reservationId}, User=${userId}, Owner=${data[i][1]}`);
         return { success: false, message: '指定された予約をキャンセルする権限がありません。' };
       }
     }
   }

   // ループを抜けても見つからなかった場合
   if (!reservationFound) {
     console.log(`キャンセル対象の予約が見つかりません: ID=${reservationId}`);
     return { success: false, message: '指定された予約IDが見つかりません。' };
   }

 } catch (error) {
   console.error('cancelReservationでエラー:', error, error.stack);
   return { success: false, message: '予約キャンセル処理中に予期せぬエラーが発生しました。' };
 } finally {
   try {
     if (lock.hasLock()) {
       lock.releaseLock();
     }
   } catch (lockError) {
     console.error('ロック解放エラー:', lockError);
   }
 }
}

/**
* 指定されたユーザーの有効な（キャンセルされておらず未来の）予約一覧を取得する
* @param {string} userId - LINEユーザーID
* @return {Array<object>} - 予約情報の配列
*/
function getUserReservations(userId) {
 console.log(`getUserReservations呼び出し: User=${userId}`);
 try {
   const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
   const sheet = ss.getSheetByName(SHEET_NAMES.RESERVATIONS);
   if (!sheet) {
     console.error('予約情報シートが見つかりません。');
     initializeSystem(); // シートがなければ初期化を試みる
     return [];
   }
   const data = sheet.getDataRange().getValues();
   const reservations = [];
   const now = new Date(); // 現在時刻

   // ヘッダー行(0)をスキップし、1行目からループ
   for (let i = 1; i < data.length; i++) {
     const row = data[i];
     // ユーザーIDが一致し、キャンセル列(10)がfalseまたは空であること
     if (row[1] === userId && (row[10] === false || row[10] === '')) {
       const reservationDateTime = new Date(row[6]); // 予約日時(6)
       // 未来の予約のみを対象とする
       if (reservationDateTime >= now) {
         // 終了時間の計算
         const endTime = row[7] ? Utilities.formatDate(new Date(row[7]), 'Asia/Tokyo', 'HH:mm') : '';
         
         // 日付フォーマット
         const dateStr = formatDate(reservationDateTime);
         
         reservations.push({
           id: row[0], // 予約ID(0)
           date: dateStr, // YYYY-MM-DD
           time: Utilities.formatDate(reservationDateTime, 'Asia/Tokyo', 'HH:mm'), // HH:MM
           endTime: endTime, // 終了時間
           description: row[12] || "パーソナルトレーニング", // 説明
           duration: row[13] || SESSION_DURATION, // 所要時間
           notes: row[14] || "" // スタッフへのメモ [14] - 新規追加
         });
       }
     }
   }

   // 日付順にソート (古い順)
   reservations.sort((a, b) => {
     const dateA = new Date(`${a.date}T${a.time}:00`);
     const dateB = new Date(`${b.date}T${b.time}:00`);
     return dateA - dateB;
   });

   console.log(`ユーザー (${userId}) の有効な予約 ${reservations.length} 件を取得`);
   return reservations;

 } catch (error) {
   console.error('getUserReservationsでエラー:', error, error.stack);
   return []; // エラー時は空配列を返す
 }
}

/**
* スプレッドシートから有効な（キャンセルされていない）全予約データを取得する
* @return {Array<object>} - 有効な予約データの配列 {id, userId, startTime, endTime, ...}
*/
function getAllValidReservations() {
 console.log('スプレッドシートから全予約データを読み込み中...');
 try {
   const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
   const sheet = ss.getSheetByName(SHEET_NAMES.RESERVATIONS);
   if (!sheet) return [];
   const data = sheet.getDataRange().getValues();
   const reservations = [];
   const now = new Date();

   // ヘッダー行(0)をスキップ
   for (let i = 1; i < data.length; i++) {
     const row = data[i];
     const isCancelled = row[10]; // キャンセル列(10)

     // キャンセルされておらず、データが不完全でない場合
     if (!isCancelled && row[0] && row[1] && row[6] && row[7]) {
        const startTime = new Date(row[6]);
        const endTime = new Date(row[7]);
        const duration = row[13] || SESSION_DURATION; // 所要時間

        // 日付オブジェクトが有効かチェック
        if (!isNaN(startTime.getTime()) && !isNaN(endTime.getTime())) {
            reservations.push({
              id: row[0],
              userId: row[1],
              startTime: startTime,
              endTime: endTime,
              duration: duration
            });
        } else {
           console.warn(`予約データの日付が無効です。スキップします。 Row=${i+1}`);
        }
     }
   }
   console.log(`有効な予約 ${reservations.length} 件をシートから取得`);

   return reservations;
 } catch (error) {
   console.error('getAllValidReservationsでエラー:', error, error.stack);
   return [];
 }
}

/**
* 指定された週の予約空き状況を取得する (クライアントサイドJSから呼び出される)
* @param {string} startDateStr - 週の開始日 (YYYY-MM-DD形式)
* @return {Array<object>} - 各日の空き状況を含む配列
*/
function getWeeklyAvailability(startDateStr) {
 console.log(`getWeeklyAvailability呼び出し: startDateStr=${startDateStr}`);
 try {
   // 日付文字列の処理
   let startDate;
   if (!startDateStr || typeof startDateStr !== 'string' || !/^\d{4}-\d{2}-\d{2}$/.test(startDateStr)) {
     console.warn(`無効な日付文字列: ${startDateStr}。本日の日付を使用します。`);
     startDate = new Date();
     startDate.setHours(0, 0, 0, 0); // 時刻をリセット
   } else {
     startDate = new Date(startDateStr + 'T00:00:00'); // タイムゾーン問題を避けるためT00:00:00を追加
     if (isNaN(startDate.getTime())) {
       console.warn(`日付のパースに失敗: ${startDateStr}。本日の日付を使用します。`);
       startDate = new Date();
       startDate.setHours(0, 0, 0, 0);
     }
   }
   
   // 週の終了日を計算
   const endDate = new Date(startDate);
   endDate.setDate(startDate.getDate() + 6);
   endDate.setHours(23, 59, 59, 999);
   
   console.log(`処理対象の週: ${formatDate(startDate)} 〜 ${formatDate(endDate)}`);
   
   // スプレッドシートから予約データを取得
   const allReservations = getAllValidReservations();
   
   // Googleカレンダーからイベントを取得
   const calendarEvents = getCalendarEvents(startDate, endDate, CALENDAR_ID);
   console.log(`Googleカレンダーから取得したイベント: ${calendarEvents.length}件`);
   
   const weeklyData = [];
   const today = new Date();
   today.setHours(0, 0, 0, 0);
   const minBookableDate = new Date(today);
   minBookableDate.setDate(today.getDate() + MIN_DAYS_AHEAD);
   const maxBookableDate = new Date(today);
   maxBookableDate.setDate(today.getDate() + DAYS_AHEAD);
   
   for (let i = 0; i < 7; i++) {
     const currentDate = new Date(startDate);
     currentDate.setDate(startDate.getDate() + i);
     
     const dateString = formatDate(currentDate); // YYYY-MM-DD
     const dayOfWeek = currentDate.getDay();
     const isHoliday = CLOSED_DAYS.includes(dayOfWeek);
     // 予約可能期間外かどうかのチェック
     const isOutsideBookingRange = currentDate < minBookableDate || currentDate > maxBookableDate;
     
     const dayInfo = {
       date: dateString,
       dayName: ["日", "月", "火", "水", "木", "金", "土"][dayOfWeek],
       isHoliday: isHoliday,
       hours: []
     };
     
     if (!isHoliday) {
       // その日の予約をフィルタリング
       const reservationsOnDate = allReservations.filter(r => {
         return formatDate(r.startTime) === dateString;
       });
       
       // その日のカレンダーイベントをフィルタリング
       const eventsOnDate = calendarEvents.filter(event => {
         if (event.isAllDay) {
           return formatDate(event.startTime) === dateString;
         }
         
         const eventStartDate = formatDate(event.startTime);
         const eventEndDate = formatDate(event.endTime);
         return (eventStartDate === dateString || eventEndDate === dateString);
       });
       
       // 営業時間内の60分間隔で空き状況を計算
       for (let h = BUSINESS_HOURS.START; h < BUSINESS_HOURS.END; h++) {
         for (let m = 0; m < 60; m += BUSINESS_HOURS.TIME_INTERVAL) {
           const timeString = `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}`;
           const slotDateTime = new Date(`${dateString}T${timeString}:00`);
           const slotEndDateTime = new Date(slotDateTime.getTime() + BUSINESS_HOURS.TIME_INTERVAL * 60 * 1000);
           
           let availableCount = 0;
           let durationAvailable = true; // セッション時間分の予約が可能かどうか
           
           // 予約可能期間内かつ過去の日付でなければ計算
           if (!isOutsideBookingRange && slotDateTime >= new Date()) {
             // この時間帯に重複する予約をチェック
             const overlappingReservations = reservationsOnDate.filter(r => 
               // 予約の開始時間または終了時間が現在のスロットと重複
               (r.startTime < slotEndDateTime && r.endTime > slotDateTime)
             );
             
             // Googleカレンダーのイベントと重複するかチェック
             const overlappingEvents = eventsOnDate.filter(event => {
               // 終日イベントの場合
               if (event.isAllDay) {
                 return true; // 終日イベントがある日は予約不可とする
               }
               
               // 通常イベントの場合、時間が重複するかチェック
               return (event.startTime < slotEndDateTime && event.endTime > slotDateTime);
             });
             
             // 予約枠から重複数を引く（最小値は0）
             const blockedSlots = overlappingReservations.length + overlappingEvents.length;
             availableCount = Math.max(0, BUSINESS_HOURS.MAX_SLOTS - blockedSlots);
             
             // セッション時間分の予約が可能かチェック
             if (availableCount > 0) {
               // セッション終了時間
               const sessionEndTime = new Date(slotDateTime.getTime() + SESSION_DURATION * 60 * 1000);
               
               // 営業時間外になるかチェック
               const businessEndTime = new Date(`${dateString}T${String(BUSINESS_HOURS.END).padStart(2, '0')}:00:00`);
               if (sessionEndTime > businessEndTime) {
                 durationAvailable = false;
               } else {
                 // セッション時間内で重複する予約をチェック
                 const durationOverlappingReservations = reservationsOnDate.filter(r => 
                   // 開始時間または終了時間がセッション時間内にある
                   (r.startTime >= slotDateTime && r.startTime < sessionEndTime) ||
                   (r.endTime > slotDateTime && r.endTime <= sessionEndTime) ||
                   // 予約がセッション全体を含む
                   (r.startTime <= slotDateTime && r.endTime >= sessionEndTime) ||
                   // セッションが予約全体を含む
                   (slotDateTime <= r.startTime && sessionEndTime >= r.endTime)
                 );
                 
                 // カレンダーイベントとの重複チェック
                 const durationOverlappingEvents = eventsOnDate.filter(event => {
                   // 終日イベント
                   if (event.isAllDay) {
                     return true; 
                   }
                   
                   // 通常イベント
                   return (
                     (event.startTime >= slotDateTime && event.startTime < sessionEndTime) ||
                     (event.endTime > slotDateTime && event.endTime <= sessionEndTime) ||
                     (event.startTime <= slotDateTime && event.endTime >= sessionEndTime) ||
                     (slotDateTime <= event.startTime && sessionEndTime >= event.endTime)
                   );
                 });
                 
                 // セッション時間内に重複がある場合は予約不可
                 if (durationOverlappingReservations.length > 0 || durationOverlappingEvents.length > 0) {
                   durationAvailable = false;
                 }
               }
             }
           } else {
             // 予約期間外または過去は予約不可
             availableCount = 0;
             durationAvailable = false;
           }
           
           dayInfo.hours.push({
             time: timeString, // HH:MM
             available: availableCount,
             durationAvailable: durationAvailable // セッション時間分の予約が可能かどうか
           });
         }
       }
     }
     weeklyData.push(dayInfo);
   }
   
   console.log(`週間予約状況生成完了: ${startDateStr}`);
   return weeklyData;
 } catch (error) {
   console.error('getWeeklyAvailabilityでエラー:', error, error.stack);
   return []; // エラー時は空配列を返す
 }
}

// ----------------------------------------
// リマインダー機能
// ----------------------------------------

/**
* 予約リマインダー用のFlexメッセージを生成する関数
* @param {string} userName - ユーザー名
* @param {string} reservationId - 予約ID
* @param {string} formattedDate - 日本語フォーマット日付（例: 2025年4月15日（火））
* @param {string} timeStr - 予約時間（HH:MM形式）
* @param {number} duration - トレーニング時間（分）
* @return {object} - LINE Flex Messageオブジェクト
*/
function createReminderFlexMessage(userName, reservationId, formattedDate, timeStr, duration = 60) {
 // 終了時間を計算
 const [hours, minutes] = timeStr.split(':').map(num => parseInt(num, 10));
 const startTime = new Date();
 startTime.setHours(hours, minutes, 0, 0);
 const endTime = new Date(startTime.getTime() + duration * 60 * 1000);
 const endTimeStr = `${String(endTime.getHours()).padStart(2, '0')}:${String(endTime.getMinutes()).padStart(2, '0')}`;

 // リマインダーのFlexメッセージ
 const flexMessage = {
   type: "flex",
   altText: "明日の予約リマインダー",
   contents: {
     type: "bubble",
     header: {
       type: "box",
       layout: "vertical",
       contents: [
         {
           type: "text",
           text: "予約リマインダー",
           weight: "bold",
           size: "md",
           color: "#FFFFFF"
         }
       ],
       backgroundColor: "#4285F4" // リマインダーは青色系
     },
     body: {
       type: "box",
       layout: "vertical",
       contents: [
         {
           type: "text",
           text: `${userName}様、明日のご予約をお知らせします`,
           weight: "bold",
           size: "md",
           wrap: true,
           margin: "md"
         },
         {
           type: "box",
           layout: "vertical",
           margin: "lg",
           spacing: "sm",
           contents: [
             {
               type: "box",
               layout: "baseline",
               spacing: "sm",
               contents: [
                 {
                   type: "text",
                   text: "日時",
                   color: "#aaaaaa",
                   size: "sm",
                   flex: 2
                 },
                 {
                   type: "text",
                   text: `${formattedDate}`,
                   wrap: true,
                   color: "#666666",
                   size: "sm",
                   flex: 8,
                   weight: "bold"
                 }
               ]
             },
             {
               type: "box",
               layout: "baseline",
               spacing: "sm",
               contents: [
                 {
                   type: "text",
                   text: "時間",
                   color: "#aaaaaa",
                   size: "sm",
                   flex: 2
                 },
                 {
                   type: "text",
                   text: `${timeStr}～${endTimeStr}`,
                   wrap: true,
                   color: "#666666",
                   size: "sm",
                   flex: 8
                 }
               ]
             },
             {
               type: "box",
               layout: "baseline",
               spacing: "sm",
               contents: [
                 {
                   type: "text",
                   text: "内容", 
                   color: "#aaaaaa",
                   size: "sm",
                   flex: 2
                 },
                 {
                   type: "text",
                   text: "パーソナルトレーニング",
                   wrap: true,
                   color: "#666666",
                   size: "sm",
                   flex: 8
                 }
               ]
             },
             {
               type: "box",
               layout: "baseline",
               spacing: "sm",
               contents: [
                 {
                   type: "text",
                   text: "準備",
                   color: "#aaaaaa",
                   size: "sm",
                   flex: 2
                 },
                 {
                   type: "text",
                   text: "動きやすい服装、タオル、室内シューズ",
                   wrap: true,
                   color: "#666666",
                   size: "sm",
                   flex: 8
                 }
               ]
             },
             {
               type: "box",
               layout: "baseline",
               spacing: "sm",
               margin: "md",
               contents: [
                 {
                   type: "text",
                   text: "ID",
                   color: "#aaaaaa",
                   size: "xs",
                   flex: 2
                 },
                 {
                   type: "text",
                   text: reservationId,
                   wrap: true,
                   color: "#999999",
                   size: "xs",
                   flex: 8
                 }
               ]
             }
           ]
         }
       ]
     },
     footer: {
       type: "box",
       layout: "vertical",
       spacing: "sm",
       contents: [
         {
           type: "text",
           text: "ご都合が悪くなった場合は、お早めにキャンセルをお願いします。",
           wrap: true,
           size: "sm",
           color: "#666666"
         },
         {
           type: "text",
           text: "当日は動きやすい服装でお越しください。",
           wrap: true,
           size: "sm",
           color: "#666666",
           margin: "md"
         }
       ],
       flex: 0
     },
     styles: {
       footer: {
         separator: true
       }
     }
   }
 };
 
 return flexMessage;
}

/**
* 予約前日にリマインドメッセージを送信する（トリガーで定期実行）
* このメソッドはPush APIを使用するため、修正なしで維持します
*/
function sendReminders() {
 console.log('sendReminders実行開始');
 try {
   const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
   const sheet = ss.getSheetByName(SHEET_NAMES.RESERVATIONS);
   if (!sheet) {
     console.error('リマインダー: 予約情報シートが見つかりません。');
     return;
   }
   const data = sheet.getDataRange().getValues();
   const now = new Date();
   const tomorrowStart = new Date(now);
   tomorrowStart.setDate(now.getDate() + 1);
   tomorrowStart.setHours(0, 0, 0, 0); // 明日の午前0時
   const tomorrowEnd = new Date(tomorrowStart);
   tomorrowEnd.setDate(tomorrowStart.getDate() + 1); // 明後日の午前0時

   let reminderCount = 0;
   // ヘッダー行(0)をスキップ
   for (let i = 1; i < data.length; i++) {
     const row = data[i];
     const reservationId = row[0]; // 予約ID列(0)
     const isCancelled = row[10]; // キャンセル列(10)
     const reminderSent = row[9]; // リマインド送信済み列(9)
     const reservationDateTime = new Date(row[6]); // 予約日時(6)
     const sessionDuration = row[13] || SESSION_DURATION; // トレーニング時間(13)

     // キャンセルされておらず、リマインド未送信で、予約が明日である場合
     if (!isCancelled && !reminderSent && reservationDateTime >= tomorrowStart && reservationDateTime < tomorrowEnd) {
       const userId = row[1]; // ユーザーID列(1)
       const userName = row[2]; // 氏名列(2)
       const timeStr = `${String(reservationDateTime.getHours()).padStart(2, '0')}:${String(reservationDateTime.getMinutes()).padStart(2, '0')}`;

       // 日付フォーマット
       const formattedDate = formatDateJapanese(reservationDateTime);

       // Flexメッセージを生成
       const flexMessage = createReminderFlexMessage(
         userName,
         reservationId,
         formattedDate,
         timeStr,
         sessionDuration
       );

       try {
         // LINE Messaging APIでFlexメッセージを送信
         const url = 'https://api.line.me/v2/bot/message/push';
         const headers = {
           'Content-Type': 'application/json; charset=UTF-8',
           'Authorization': 'Bearer ' + LINE_ACCESS_TOKEN,
         };
         const payload = {
           to: userId,
           messages: [flexMessage]
         };
         const options = {
           method: 'post',
           headers: headers,
           payload: JSON.stringify(payload),
           muteHttpExceptions: true
         };

         const response = UrlFetchApp.fetch(url, options);
         const responseCode = response.getResponseCode();
         
         if (responseCode === 200) {
           // 送信成功したらスプレッドシートのフラグを更新
           sheet.getRange(i + 1, 10).setValue(true); // リマインド送信済み列(10)にtrueを設定
           reminderCount++;
           console.log(`リマインドFlexメッセージ送信成功: User=${userId}, ReservationID=${reservationId}`);
         } else {
           console.error(`リマインドFlexメッセージ送信エラー: Code=${responseCode}, User=${userId}, ReservationID=${reservationId}`);
           
           // フォールバック: 通常のテキストメッセージを送信
           const message = `【予約リマインダー】\n\n` +
                         `${userName}様\n\n` +
                         `明日のご予約についてお知らせします。\n\n` +
                         `日時: ${formattedDate} ${timeStr}\n` +
                         `内容: パーソナルトレーニング\n\n` +
                         `ご来店をお待ちしております。\n` +
                         `ご都合が悪くなった場合は、お早めに「予約確認」からキャンセルをお願いします。`;
           const success = sendLineMessage(userId, message);
           
           if (success) {
             sheet.getRange(i + 1, 10).setValue(true); // リマインド送信済み列(10)にtrueを設定
             reminderCount++;
             console.log(`リマインドテキストメッセージ送信成功: User=${userId}, ReservationID=${reservationId}`);
           } else {
             console.error(`リマインド送信完全失敗: User=${userId}, ReservationID=${reservationId}`);
           }
         }
       } catch (sendError) {
         console.error(`リマインド送信処理エラー: User=${userId}, ReservationID=${reservationId}`, sendError);
         
         // エラー時のフォールバック処理
         const message = `【予約リマインダー】\n\n` +
                       `${userName}様\n\n` +
                       `明日のご予約についてお知らせします。\n\n` +
                       `日時: ${formattedDate} ${timeStr}\n` +
                       `内容: パーソナルトレーニング\n\n` +
                       `ご来店をお待ちしております。\n` +
                       `ご都合が悪くなった場合は、お早めに「予約確認」からキャンセルをお願いします。`;
         const success = sendLineMessage(userId, message);
         
         if (success) {
           sheet.getRange(i + 1, 10).setValue(true); // リマインド送信済み列(10)にtrueを設定
           reminderCount++;
           console.log(`リマインドフォールバック送信成功: User=${userId}, ReservationID=${reservationId}`);
         }
       }
       
       // API制限回避のため少し待機
       Utilities.sleep(300);
     }
   }
   console.log(`sendReminders実行完了: ${reminderCount}件送信`);
 } catch (error) {
   console.error('sendRemindersでエラー:', error, error.stack);
 }
}

/**
* sendReminders関数を実行するための時間ベースのトリガーを設定する
*/
function setupRemindTrigger() {
 // 既存のsendRemindersトリガーを削除
 const triggers = ScriptApp.getProjectTriggers();
 triggers.forEach(trigger => {
   if (trigger.getHandlerFunction() === 'sendReminders') {
     ScriptApp.deleteTrigger(trigger);
     console.log('既存のリマインダートリガーを削除しました。');
   }
 });

 // 毎日指定した時刻（例: 午前9時）に実行するトリガーを作成
 ScriptApp.newTrigger('sendReminders')
   .timeBased()
   .everyDays(1)
   .atHour(9) // 例: 毎日午前9時に実行
   .inTimezone('Asia/Tokyo') // タイムゾーンを指定
   .create();
 console.log('新しいリマインダートリガー（毎日午前9時）を設定しました。');
}

// ----------------------------------------
// 初期化・ヘルパー関数
// ----------------------------------------

/**
* システム初期化（スプレッドシートのシートとヘッダーを作成）
*/
function initializeSystem() {
 try {
   const ss = SpreadsheetApp.getActiveSpreadsheet() || SpreadsheetApp.openById(SPREADSHEET_ID); // アクティブまたはIDで開く
   let sheetCreated = false;

   // ユーザー情報シート
   if (!ss.getSheetByName(SHEET_NAMES.USERS)) {
     const usersSheet = ss.insertSheet(SHEET_NAMES.USERS);
     usersSheet.appendRow(['UID', '氏名', '電話番号', 'メールアドレス', '性別', '生年月日', '登録日時', '知ったきっかけ']);
     usersSheet.setFrozenRows(1);
     console.log(`${SHEET_NAMES.USERS}シートを作成しました。`);
     sheetCreated = true;
   }

   // 予約情報シート
   if (!ss.getSheetByName(SHEET_NAMES.RESERVATIONS)) {
     const reservationsSheet = ss.insertSheet(SHEET_NAMES.RESERVATIONS);
     reservationsSheet.appendRow(['予約ID', 'UID', '氏名', '電話番号', 'メニューID', 'スタッフID', '予約日時', '終了日時', '予約作成日時', 'リマインド送信済', 'キャンセル済', 'キャンセル日時', '内容', '時間(分)']);
     reservationsSheet.setFrozenRows(1);
     // 日付列の書式設定
     reservationsSheet.getRange('G:H').setNumberFormat('yyyy/mm/dd hh:mm');
     reservationsSheet.getRange('I:I').setNumberFormat('yyyy/mm/dd hh:mm:ss');
     reservationsSheet.getRange('L:L').setNumberFormat('yyyy/mm/dd hh:mm:ss');
     console.log(`${SHEET_NAMES.RESERVATIONS}シートを作成しました。`);
     sheetCreated = true;
   }

   // 設定シート
   if (!ss.getSheetByName(SHEET_NAMES.SETTINGS)) {
     const settingsSheet = ss.insertSheet(SHEET_NAMES.SETTINGS);
     settingsSheet.appendRow(['設定項目', '値']);
     settingsSheet.appendRow(['定休日 (曜日番号)', CLOSED_DAYS.join(',')]);
     settingsSheet.appendRow(['予約開始日数前', MIN_DAYS_AHEAD]);
     settingsSheet.appendRow(['予約可能日数', DAYS_AHEAD]);
     settingsSheet.setFrozenRows(1);
     console.log(`${SHEET_NAMES.SETTINGS}シートを作成しました。`);
     sheetCreated = true;
   }

   if (sheetCreated) {
      SpreadsheetApp.flush(); // 変更を即時反映
      console.log('システム初期化完了。');
   }

 } catch (error) {
   console.error('システム初期化中にエラーが発生しました:', error, error.stack);
   throw new Error('システム初期化に失敗しました: ' + error.message);
 }
}

/**
 * ユーザー用の一時トークンを生成して保存する
 * @param {string} userId - LINE ユーザーID
 * @return {string} - 生成されたトークン
 */
function generateTokenForUser(userId) {
  // ランダムなトークンを生成
  const token = Utilities.getUuid();
  
  // 有効期限を設定（現在時刻から30分後）
  const expiryTime = new Date();
  expiryTime.setMinutes(expiryTime.getMinutes() + 30);
  
  // スプレッドシートに保存
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  let tokenSheet = ss.getSheetByName('一時トークン');
  
  // シートがなければ作成
  if (!tokenSheet) {
    tokenSheet = ss.insertSheet('一時トークン');
    tokenSheet.appendRow(['トークン', 'ユーザーID', '有効期限', '作成日時']);
  }
  
  // トークン情報を保存
  tokenSheet.appendRow([
    token,
    userId,
    expiryTime,
    new Date()
  ]);
  
  return token;
}

/**
 * トークンからユーザーIDを取得
 * @param {string} token - チェックするトークン
 * @return {string|null} - 有効なトークンの場合はユーザーID、無効な場合はnull
 */
function getUserIdFromToken(token) {
  if (!token) return null;
  
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  const tokenSheet = ss.getSheetByName('一時トークン');
  if (!tokenSheet) return null;
  
  const now = new Date();
  const data = tokenSheet.getDataRange().getValues();
  
  // ヘッダー行をスキップして検索
  for (let i = 1; i < data.length; i++) {
    if (data[i][0] === token) { // トークン列
      const expiryTime = new Date(data[i][2]); // 有効期限列
      
      // 有効期限内かチェック
      if (now <= expiryTime) {
        return data[i][1]; // ユーザーID列を返す
      } else {
        // 期限切れの場合は削除対象としてマーク
        return null;
      }
    }
  }
  
  return null; // トークンが見つからない
}

/**
 * 定期的に期限切れトークンを削除するクリーンアップ関数
 */
function cleanupExpiredTokens() {
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  const tokenSheet = ss.getSheetByName('一時トークン');
  if (!tokenSheet) return;
  
  const now = new Date();
  const data = tokenSheet.getDataRange().getValues();
  const rowsToDelete = [];
  
  // 期限切れの行を特定（後ろから検索して削除対象をマーク）
  for (let i = data.length - 1; i > 0; i--) { // ヘッダー行を除く
    const expiryTime = new Date(data[i][2]); // 有効期限列
    if (now > expiryTime) {
      rowsToDelete.push(i + 1); // シートの行番号（インデックス+1）
    }
  }
  
  // 特定した行を削除
  for (const rowNum of rowsToDelete) {
    tokenSheet.deleteRow(rowNum);
  }
}

/**
* 既存のスプレッドシートに「知ったきっかけ」カラムを追加するヘルパー関数
* (既存のスプレッドシートを使用している場合、一度だけ実行してください)
*/
function addReferralSourceColumn() {
 try {
   const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
   const sheet = ss.getSheetByName(SHEET_NAMES.USERS);
   if (sheet) {
     const lastColumn = sheet.getLastColumn();
     if (lastColumn < 8) { // 8列目が「知ったきっかけ」
       sheet.getRange(1, 8).setValue('知ったきっかけ');
       console.log('「知ったきっかけ」カラムをユーザー情報シートに追加しました。');
     } else {
       console.log('既に十分な列数が存在しています。変更は行いませんでした。');
     }
   } else {
     console.error('ユーザー情報シートが見つかりません。');
   }
 } catch (error) {
   console.error('addReferralSourceColumnでエラー:', error, error.stack);
 }
}


// ----------------------------------------
// セットアップ・テスト用関数
// ----------------------------------------

/**
* システム全体のセットアップを実行する（手動実行用）
* スプレッドシート初期化とトリガー設定を行う
*/
function setupSystem() {
 try {
   console.log('システムセットアップ開始...');
   initializeSystem(); // スプレッドシート初期化
   setupRemindTrigger(); // リマインダートリガー設定
   console.log('システムセットアップ完了。スクリプトプロパティ（LINE_ACCESS_TOKEN, CALENDAR_ID, SPREADSHEET_ID）を設定してください。');
   // スクリプトプロパティ設定を促すメッセージ
   SpreadsheetApp.getUi().alert('システムセットアップ完了。ファイル > プロジェクトの設定 > スクリプト プロパティ で、LINE_ACCESS_TOKEN, CALENDAR_ID, SPREADSHEET_ID を設定してください。');
 } catch (error) {
   console.error('setupSystemでエラー:', error, error.stack);
    SpreadsheetApp.getUi().alert('システムセットアップ中にエラーが発生しました。\n' + error.message);
 }
}
