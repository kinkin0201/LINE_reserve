/**
 * LINE予約システム - Google Apps Script
 *
 * 機能:
 * - LINEからのメッセージに応答して予約フォームURL、予約一覧、ヘルプを表示
 * - Webアプリで会員登録と予約フォームを提供
 * - 予約可能な日時をカレンダー形式で表示 (30分間隔)
 * - 予約作成、確認、キャンセル機能
 * - GoogleスプレッドシートとGoogleカレンダーとの連携
 * - 予約前日のリマインドメッセージ送信
 */

// ----------------------------------------
// 定数と設定
// ----------------------------------------

// ▼▼▼ 環境に合わせて設定してください ▼▼▼
const LINE_ACCESS_TOKEN = PropertiesService.getScriptProperties().getProperty('LINE_ACCESS_TOKEN') || 'Fin/wrDQ7zD97gikfIDWe3Gjs/ZIgMgAm4jX6olnADVxVEP4S+3qAWorOjHhUJYHAqa3eW+6aL/nV5wbU2RX4WuFN+70e6UzpFeCdLRXNkY9OBgD/DYhRKrVqElUb0CXTAfjV31MQEcTrya+8z2tYgdB04t89/1O/w1cDnyilFU='; // LINE Messaging APIのアクセストークン (スクリプトプロパティから取得)
const CALENDAR_ID = PropertiesService.getScriptProperties().getProperty('CALENDAR_ID') || 'c_9d24918fa9b40d73dd51c600630ff38b2a96508a8bf5bb25029a89c91947a105@group.calendar.google.com'; // 予約管理用GoogleカレンダーID (スクリプトプロパティから取得)
const SPREADSHEET_ID = PropertiesService.getScriptProperties().getProperty('SPREADSHEET_ID') || '1EZBFDKrK84mUkhHpMp-8lRUjXaox6Nlz_DqlvYFA2kY'; // データベース用スプレッドシートID (スクリプトプロパティから取得)
// ▲▲▲ 環境に合わせて設定してください ▲▲▲

// シート名
const SHEET_NAMES = {
  USERS: 'ユーザー情報',
  RESERVATIONS: '予約情報',
  SETTINGS: '設定' // 設定シートは現在直接利用していませんが、将来的な拡張のため残します
};

// 予約設定
const BUSINESS_HOURS = {
  START: 10, // 営業開始時間 (10:00)
  END: 20,   // 営業終了時間 (20:00) - この時間ちょうどは予約不可
  DURATION: 60, // 予約のデフォルト所要時間（分）
  MAX_SLOTS: 3, // 同時刻の最大予約数
  MAX_USER_RESERVATIONS: 3, // 1ユーザーあたりの最大予約数（未来の予約）
  TIME_INTERVAL: 30 // 予約可能な時間間隔（分）
};

// メニュー情報
const MENU_PLANS = [
  { id: 'A', name: 'Aプラン（カット）', price: 3300 },
  { id: 'B', name: 'Bプラン（パーマ）', price: 5500 },
  { id: 'C', name: 'Cプラン（カラー）', price: 4400 }
];

// スタッフ情報
const STAFF_MEMBERS = [
  { id: 'sato', name: '佐藤さん' },
  { id: 'tanaka', name: '田中さん' },
  { id: 'takahashi', name: '高橋さん' },
  { id: 'none', name: '指名なし' }
];

// 予約可能日数（今日から何日先まで予約可能か）
const DAYS_AHEAD = 30;

// 予約可能開始日（今日から何日後から予約可能か）
const MIN_DAYS_AHEAD = 2;

// 定休日の設定（0:日曜, 1:月曜, 2:火曜, 3:水曜, 4:木曜, 5:金曜, 6:土曜）
const CLOSED_DAYS = [1]; // 月曜日が定休日

// ----------------------------------------
// Webhook (LINEからのリクエスト受信)
// ----------------------------------------

/**
 * LINE Messaging APIからのPOSTリクエストを処理する
 * @param {object} e - イベントオブジェクト
 * @return {object} - ContentService TextOutput
 */
function doPost(e) {
  console.log('doPost関数が呼び出されました');
  try {
    // リクエストボディの存在チェック
    if (!e || !e.postData || !e.postData.contents) {
      console.error('無効なリクエスト: postDataまたはcontentsがありません');
      return createJsonResponse({ status: 'error', message: 'Invalid request: No postData or contents' });
    }

    const contents = JSON.parse(e.postData.contents);

    // イベント配列の存在チェック
    if (!contents.events || !Array.isArray(contents.events)) {
      console.error('無効なリクエスト: events配列がありません');
      return createJsonResponse({ status: 'error', message: 'Invalid request: No events array' });
    }

    // 各イベントを処理
    contents.events.forEach(event => {
      if (!event || !event.source || !event.source.userId) {
        console.warn('Skipping event due to missing source or userId:', JSON.stringify(event));
        return; // ユーザーIDがないイベントはスキップ
      }

      switch (event.type) {
        case 'message':
          if (event.message && event.message.type === 'text') {
            handleUserMessage(event);
          }
          break;
        case 'postback':
          handlePostback(event);
          break;
        case 'follow':
          handleFollow(event);
          break;
        // 必要に応じて他のイベントタイプ（unfollowなど）の処理を追加
        default:
          console.log('未対応のイベントタイプ:', event.type);
      }
    });

    // 正常終了
    return createJsonResponse({ status: 'success' });

  } catch (error) {
    console.error('doPostでエラーが発生しました:', error, error.stack);
    // LINEプラットフォームへのエラー応答
    return createJsonResponse({ status: 'error', message: 'Internal Server Error: ' + error.message });
  }
}

/**
 * JSONレスポンスを生成するヘルパー関数
 * @param {object} obj - レスポンスオブジェクト
 * @return {object} - ContentService TextOutput
 */
function createJsonResponse(obj) {
  return ContentService.createTextOutput(JSON.stringify(obj))
    .setMimeType(ContentService.MimeType.JSON);
}

// ----------------------------------------
// LINEイベントハンドラ
// ----------------------------------------

/**
 * テキストメッセージイベントを処理する
 * @param {object} event - LINEイベントオブジェクト
 */
function handleUserMessage(event) {
  const userId = event.source.userId;
  const userMessage = event.message.text.trim(); // 前後の空白を除去
  console.log(`メッセージ受信: UserID=${userId}, Message='${userMessage}'`);

  try {
    if (!userId) {
      console.error('handleUserMessage: userIdがありません');
      return;
    }

    // メッセージ内容に応じた処理分岐
    if (userMessage === '予約する' || userMessage === '予約') {
      sendReservationUrl(userId);
    } else if (userMessage === '予約確認') {
      sendReservationList(userId);
    } else if (userMessage === 'ヘルプ') {
      sendHelpMessage(userId);
    } else if (userMessage.toLowerCase().startsWith('キャンセル:')) { // 大文字小文字を区別しない
      const parts = userMessage.split(':');
      if (parts.length > 1) {
        const reservationId = parts[1].trim();
        if (reservationId) {
          const result = cancelReservation(reservationId, userId);
          sendLineMessage(userId, result.message);
        } else {
          sendLineMessage(userId, 'キャンセルする予約IDを指定してください。\n例: キャンセル:12345abc');
        }
      } else {
        sendLineMessage(userId, 'キャンセルする予約IDを指定してください。\n例: キャンセル:12345abc');
      }
    } else {
      // 上記以外の場合はデフォルトメッセージを送信
      sendDefaultMessage(userId);
    }
  } catch (error) {
    console.error(`handleUserMessageでエラー UserID=${userId}:`, error, error.stack);
    sendLineMessage(userId, 'エラーが発生しました。しばらくしてからもう一度お試しください。');
  }
}

/**
 * ポストバックイベントを処理する
 * @param {object} event - LINEイベントオブジェクト
 */
function handlePostback(event) {
  const userId = event.source.userId;
  const data = event.postback.data;
  console.log(`ポストバック受信: UserID=${userId}, Data='${data}'`);

  try {
    if (!userId) {
      console.error('handlePostback: userIdがありません');
      return;
    }

    // ポストバックデータに応じた処理
    if (data.startsWith('cancel_reservation:')) {
      const reservationId = data.split(':')[1];
      if (reservationId) {
        const result = cancelReservation(reservationId, userId);
        sendLineMessage(userId, result.message);
      } else {
        sendLineMessage(userId, 'キャンセル処理でエラーが発生しました。(ID不明)');
      }
    }
    // 必要に応じて他のポストバック処理を追加
  } catch (error) {
    console.error(`handlePostbackでエラー UserID=${userId}, Data=${data}:`, error, error.stack);
    sendLineMessage(userId, '処理中にエラーが発生しました。');
  }
}

/**
 * フォロー（友達追加）イベントを処理する
 * @param {object} event - LINEイベントオブジェクト
 */
function handleFollow(event) {
  const userId = event.source.userId;
  console.log(`フォロー受信: UserID=${userId}`);

  try {
    if (!userId) {
      console.error('handleFollow: userIdがありません');
      return;
    }

    // 友達追加時のウェルカムメッセージ
    sendLineMessage(userId,
      'ご登録ありがとうございます！\n\n' +
      'このLINEアカウントでは予約の管理ができます。\n\n' +
      '【使い方】\n' +
      '・「予約する」と送信すると予約フォームのURLが送られます\n' +
      '・「予約確認」と送信すると現在の予約一覧が表示されます\n' +
      '・「ヘルプ」と送信するとヘルプ情報が表示されます'
    );
  } catch (error) {
    console.error(`handleFollowでエラー UserID=${userId}:`, error, error.stack);
    // フォローイベントでのエラーはユーザーに通知しない方が良い場合もある
  }
}

// ----------------------------------------
// LINEメッセージ送信関数
// ----------------------------------------

/**
 * 予約フォームのURLをLINEで送信する
 * @param {string} userId - 送信先LINEユーザーID
 */
function sendReservationUrl(userId) {
  try {
    const webAppUrl = ScriptApp.getService().getUrl();
    // ユーザーIDをパラメータとして付与
    const reservationUrl = `${webAppUrl}?userId=${encodeURIComponent(userId)}`;

    sendLineMessage(userId,
      '下記のURLからご予約ください。\n\n' + reservationUrl
    );
  } catch (error) {
    console.error(`sendReservationUrlでエラー UserID=${userId}:`, error, error.stack);
    sendLineMessage(userId, '予約ページのURL取得中にエラーが発生しました。');
  }
}

/**
 * ユーザーの予約一覧をLINEで送信する
 * @param {string} userId - 送信先LINEユーザーID
 */
function sendReservationList(userId) {
  try {
    const reservations = getUserReservations(userId); // 未来の予約のみ取得

    if (!reservations || reservations.length === 0) {
      sendLineMessage(userId, '現在、有効な予約はありません。');
      return;
    }

    let message = '【現在の予約一覧】\n\n';
    reservations.forEach((reservation, index) => {
      // メニュー名とスタッフ名を取得
      const menu = MENU_PLANS.find(m => m.id === reservation.menu) || { name: reservation.menu };
      const staff = STAFF_MEMBERS.find(s => s.id === reservation.staff) || { name: reservation.staff };

      message += `${index + 1}. ${reservation.date} ${reservation.time}\n`;
      message += `  メニュー: ${menu.name}\n`;
      message += `  担当: ${staff.name}\n`;
      message += `  予約ID: ${reservation.id}\n\n`;
    });

    message += '予約をキャンセルする場合は、「キャンセル:<予約ID>」と入力して送信してください。\n';
    message += '(例: キャンセル:a1b2c3d4)';

    sendLineMessage(userId, message);
  } catch (error) {
    console.error(`sendReservationListでエラー UserID=${userId}:`, error, error.stack);
    sendLineMessage(userId, '予約情報の取得中にエラーが発生しました。');
  }
}

/**
 * ヘルプメッセージをLINEで送信する
 * @param {string} userId - 送信先LINEユーザーID
 */
function sendHelpMessage(userId) {
  const closedDayNames = CLOSED_DAYS.map(dayIndex => ["日", "月", "火", "水", "木", "金", "土"][dayIndex]).join('、');
  sendLineMessage(userId,
    '【ヘルプ】\n\n' +
    '・「予約する」: 予約フォームを開きます\n' +
    '・「予約確認」: 現在の予約を確認します\n' +
    '・「キャンセル:<予約ID>」: 指定したIDの予約をキャンセルします\n\n' +
    `営業時間: ${BUSINESS_HOURS.START}:00～${BUSINESS_HOURS.END}:00\n` +
    `定休日: ${closedDayNames || 'なし'}\n` +
    `予約可能期間: ${MIN_DAYS_AHEAD}日後～${DAYS_AHEAD}日後まで\n` +
    `最大予約数: お一人様${BUSINESS_HOURS.MAX_USER_RESERVATIONS}件まで`
  );
}

/**
 * デフォルトの応答メッセージをLINEで送信する
 * @param {string} userId - 送信先LINEユーザーID
 */
function sendDefaultMessage(userId) {
  sendLineMessage(userId,
    'ご利用ありがとうございます。\n\n' +
    '下記のメニューからお選びいただくか、メッセージを入力してください。\n' +
    '・予約する\n' +
    '・予約確認\n' +
    '・ヘルプ'
  );
}

/**
 * LINE Messaging APIを使用してテキストメッセージを送信する
 * @param {string} userId - 送信先LINEユーザーID
 * @param {string} messageText - 送信するメッセージ本文
 * @return {boolean} - 送信成功時はtrue、失敗時はfalse
 */
function sendLineMessage(userId, messageText) {
  if (!userId || !messageText) {
    console.error('sendLineMessage: userIdまたはmessageTextがありません。');
    return false;
  }
  if (!LINE_ACCESS_TOKEN || LINE_ACCESS_TOKEN === 'YOUR_LINE_MESSAGING_API_ACCESS_TOKEN') {
     console.error('LINEアクセストークンが設定されていません。スクリプトプロパティを確認してください。');
     // 開発中はコンソールエラーのみとし、本番では通知などの仕組みを検討
     return false;
  }

  console.log(`LINEメッセージ送信: UserID=${userId}, Message='${messageText.substring(0, 50)}...'`); // 長いメッセージは省略してログ表示
  const url = 'https://api.line.me/v2/bot/message/push';
  const headers = {
    'Content-Type': 'application/json; charset=UTF-8',
    'Authorization': 'Bearer ' + LINE_ACCESS_TOKEN,
  };
  const payload = {
    to: userId,
    messages: [
      {
        type: 'text',
        text: messageText,
      },
    ],
  };
  const options = {
    method: 'post',
    headers: headers,
    payload: JSON.stringify(payload),
    muteHttpExceptions: true // エラー時にもレスポンスを取得するため
  };

  try {
    const response = UrlFetchApp.fetch(url, options);
    const responseCode = response.getResponseCode();
    const responseBody = response.getContentText();

    if (responseCode === 200) {
      console.log('LINEメッセージ送信成功:', responseCode);
      return true;
    } else {
      console.error(`LINEメッセージ送信失敗: Code=${responseCode}, Body=${responseBody}`);
      // エラー内容に応じて、再試行や管理者への通知などを検討
      return false;
    }
  } catch (error) {
    console.error('LINEメッセージ送信中に例外発生:', error, error.stack);
    return false;
  }
}

// ----------------------------------------
// Webアプリ (HTMLサービス)
// ----------------------------------------

/**
 * WebアプリへのGETリクエストを処理する
 * @param {object} e - イベントオブジェクト (e.parameter.userId を含む)
 * @return {object} - HtmlService Output
 */
function doGet(e) {
  console.log('doGet関数が呼び出されました:', JSON.stringify(e.parameter));
  try {
    const userId = e.parameter.userId;

    // userIdがない場合はエラーページを表示
    if (!userId) {
      console.error('doGet: userIdパラメータがありません');
      return HtmlService.createHtmlOutput(
        '<p>エラー: 不正なアクセスです。LINEのメニューから再度アクセスしてください。</p>'
      ).setTitle('エラー');
    }

    // システム（スプレッドシート）の初期化を確認・実行
    initializeSystem();

    // ユーザー情報を取得
    const userInfo = getUserInfo(userId);

    if (userInfo) {
      // ユーザー情報があれば予約フォームを表示
      console.log(`ユーザー情報が見つかりました (${userId})。予約フォームを表示します。`);
      return showReservationForm(userId, userInfo);
    } else {
      // ユーザー情報がなければ会員登録フォームを表示
      console.log(`ユーザー情報が見つかりません (${userId})。会員登録フォームを表示します。`);
      return showRegistrationForm(userId);
    }
  } catch (error) {
    console.error('doGetでエラーが発生しました:', error, error.stack);
    return HtmlService.createHtmlOutput(
      '<p>エラーが発生しました。しばらくしてからもう一度お試しください。</p><p>詳細: ' + error.message + '</p>'
    ).setTitle('エラー');
  }
}

/**
 * 会員登録フォームのHTMLページを生成して表示する
 * @param {string} userId - LINEユーザーID
 * @return {object} - HtmlService Output
 */
function showRegistrationForm(userId) {
  try {
    // HTMLテンプレートを取得
    const template = HtmlService.createTemplateFromFile('registration');
    // テンプレートにユーザーIDを渡す
    template.userId = userId;
    // HTMLを評価してHtmlOutputオブジェクトを生成
    const htmlOutput = template.evaluate();
    htmlOutput.setTitle('会員登録');
    // 必要に応じてX-Frame-Optionsヘッダーを設定 (LINE内ブラウザで表示する場合)
    htmlOutput.setXFrameOptionsMode(HtmlService.XFrameOptionsMode.ALLOWALL);
    return htmlOutput;
  } catch (error) {
    console.error('showRegistrationFormでエラー:', error, error.stack);
    return HtmlService.createHtmlOutput('<p>会員登録ページの表示中にエラーが発生しました。</p>');
  }
}

/**
 * 予約フォームのHTMLページを生成して表示する
 * @param {string} userId - LINEユーザーID
 * @param {object} userInfo - ユーザー情報オブジェクト
 * @return {object} - HtmlService Output
 */
function showReservationForm(userId, userInfo) {
  try {
    // HTMLテンプレートを取得
    const template = HtmlService.createTemplateFromFile('reservation');

    // テンプレートに変数を渡す
    template.userId = userId;
    template.userName = userInfo.name;
    template.userPhone = userInfo.phone; // 電話番号も渡す

    // 予約可能な期間を計算
    const today = new Date();
    const startDate = new Date();
    startDate.setDate(today.getDate() + MIN_DAYS_AHEAD); // 最小日数後から
    const endDate = new Date();
    endDate.setDate(today.getDate() + DAYS_AHEAD); // 最大日数後まで

    template.startDate = formatDate(startDate); // YYYY-MM-DD形式
    template.endDate = formatDate(endDate);     // YYYY-MM-DD形式

    // メニュープランとスタッフ情報をJSON文字列として渡す
    template.menuPlansJson = JSON.stringify(MENU_PLANS);
    template.staffMembersJson = JSON.stringify(STAFF_MEMBERS);

    // 営業時間とその他の設定を渡す
    template.businessHoursJson = JSON.stringify(BUSINESS_HOURS);
    template.closedDaysJson = JSON.stringify(CLOSED_DAYS);
    template.minDaysAhead = MIN_DAYS_AHEAD;
    template.daysAhead = DAYS_AHEAD;

    // HTMLを評価してHtmlOutputオブジェクトを生成
    const htmlOutput = template.evaluate();
    htmlOutput.setTitle('予約フォーム');
    htmlOutput.setXFrameOptionsMode(HtmlService.XFrameOptionsMode.ALLOWALL);
    return htmlOutput;
  } catch (error) {
    console.error('showReservationFormでエラー:', error, error.stack);
    return HtmlService.createHtmlOutput('<p>予約ページの表示中にエラーが発生しました。</p>');
  }
}

// ----------------------------------------
// 予約関連コアロジック
// ----------------------------------------

/**
 * 指定された週の予約空き状況を取得する (クライアントサイドJSから呼び出される)
 * @param {string} startDateStr - 週の開始日 (YYYY-MM-DD形式)
 * @return {Array<object>} - 各日の空き状況を含む配列
 */
function getWeeklyAvailability(startDateStr) {
  console.log(`getWeeklyAvailability呼び出し: startDateStr=${startDateStr}`);
  try {
    let startDate;
    // 日付文字列の妥当性チェックとパース
    if (!startDateStr || typeof startDateStr !== 'string' || !/^\d{4}-\d{2}-\d{2}$/.test(startDateStr)) {
      console.warn(`無効な日付文字列: ${startDateStr}。本日の日付を使用します。`);
      startDate = new Date();
      startDate.setHours(0, 0, 0, 0); // 時刻をリセット
    } else {
      startDate = new Date(startDateStr + 'T00:00:00'); // タイムゾーン問題を避けるためT00:00:00を追加
      if (isNaN(startDate.getTime())) {
        console.warn(`日付のパースに失敗: ${startDateStr}。本日の日付を使用します。`);
        startDate = new Date();
        startDate.setHours(0, 0, 0, 0);
      }
    }
    console.log(`処理対象の週開始日: ${formatDate(startDate)}`);

    // スプレッドシートから予約データを取得 (キャッシュ利用を検討)
    const allReservations = getAllValidReservations(); // 有効な予約のみ取得

    const weeklyData = [];
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const minBookableDate = new Date(today);
    minBookableDate.setDate(today.getDate() + MIN_DAYS_AHEAD);
    const maxBookableDate = new Date(today);
    maxBookableDate.setDate(today.getDate() + DAYS_AHEAD);

    for (let i = 0; i < 7; i++) {
      const currentDate = new Date(startDate);
      currentDate.setDate(startDate.getDate() + i);
      const dateString = formatDate(currentDate); // YYYY-MM-DD
      const dayOfWeek = currentDate.getDay();
      const isHoliday = CLOSED_DAYS.includes(dayOfWeek);
      // 予約可能期間外かどうかのチェック
      const isOutsideBookingRange = currentDate < minBookableDate || currentDate > maxBookableDate;

      const dayInfo = {
        date: dateString,
        dayName: ["日", "月", "火", "水", "木", "金", "土"][dayOfWeek],
        isHoliday: isHoliday,
        hours: []
      };

      if (!isHoliday) {
        // その日の予約をフィルタリング
        const reservationsOnDate = allReservations.filter(r => formatDate(r.startTime) === dateString);
        // console.log(`${dateString}の予約数: ${reservationsOnDate.length}`);

        // 営業時間内の30分間隔で空き状況を計算
        for (let h = BUSINESS_HOURS.START; h < BUSINESS_HOURS.END; h++) {
          for (let m = 0; m < 60; m += BUSINESS_HOURS.TIME_INTERVAL) {
            const timeString = `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}`;
            const slotDateTime = new Date(`${dateString}T${timeString}:00`);
            let availableCount = 0;

            // 予約可能期間内かつ過去の日付でなければ計算
            if (!isOutsideBookingRange && slotDateTime >= new Date()) {
              // この時間帯の予約数をカウント
              const reservedCount = reservationsOnDate.filter(r =>
                r.startTime.getHours() === h && r.startTime.getMinutes() === m
              ).length;
              availableCount = Math.max(0, BUSINESS_HOURS.MAX_SLOTS - reservedCount);
            } else {
              // 予約期間外または過去は予約不可
              availableCount = 0;
            }


            dayInfo.hours.push({
              time: timeString, // HH:MM
              available: availableCount,
              // timestamp: slotDateTime.getTime() // 必要であればタイムスタンプも返す
            });
          }
        }
      }
      weeklyData.push(dayInfo);
    }
    console.log(`週間空き状況生成完了: ${startDateStr}`);
    return weeklyData;
  } catch (error) {
    console.error('getWeeklyAvailabilityでエラー:', error, error.stack);
    // エラー時は空配列を返すか、エラー情報を含むオブジェクトを返す
    return []; // クライアント側でエラー処理できるように空配列を返す
  }
}


/**
 * 新しい予約を作成する (クライアントサイドJSから呼び出される)
 * @param {object} reservationData - 予約情報 (userId, menu, staff, date, time)
 * @return {object} - { success: boolean, message: string, reservationInfo?: object }
 */
function createReservation(reservationData) {
  console.log('createReservation呼び出し:', JSON.stringify(reservationData));
  const lock = LockService.getScriptLock();
  try {
    lock.waitLock(15000); // 最大15秒待機

    // --- バリデーション ---
    if (!reservationData || !reservationData.userId || !reservationData.menu || !reservationData.staff || !reservationData.date || !reservationData.time) {
      return { success: false, message: '予約情報が不足しています。' };
    }

    // ユーザー情報取得
    const userInfo = getUserInfo(reservationData.userId);
    if (!userInfo) {
      return { success: false, message: 'ユーザー情報が見つかりません。会員登録を完了してください。' };
    }

    // 予約日時パース
    const reservationDateTime = new Date(`${reservationData.date}T${reservationData.time}:00`);
    if (isNaN(reservationDateTime.getTime())) {
      return { success: false, message: '日時の形式が無効です。' };
    }

    // 現在時刻
    const now = new Date();

    // 予約数上限チェック (未来の予約のみカウント)
    const userReservations = getUserReservations(reservationData.userId);
    if (userReservations.length >= BUSINESS_HOURS.MAX_USER_RESERVATIONS) {
      return { success: false, message: `予約数が上限（${BUSINESS_HOURS.MAX_USER_RESERVATIONS}件）に達しています。` };
    }

    // 予約可能期間チェック
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const minBookableDate = new Date(today);
    minBookableDate.setDate(today.getDate() + MIN_DAYS_AHEAD);
    const maxBookableDate = new Date(today);
    maxBookableDate.setDate(today.getDate() + DAYS_AHEAD);
    maxBookableDate.setHours(23, 59, 59, 999); // 終了日の終わりまで

    if (reservationDateTime < minBookableDate || reservationDateTime > maxBookableDate) {
      return { success: false, message: `予約可能期間（${MIN_DAYS_AHEAD}日後～${DAYS_AHEAD}日後）外です。` };
    }
     // 過去日時チェック
    if (reservationDateTime < now) {
        return { success: false, message: '過去の日時を予約することはできません。' };
    }

    // 定休日チェック
    if (CLOSED_DAYS.includes(reservationDateTime.getDay())) {
      return { success: false, message: '選択された日は定休日です。' };
    }

    // 営業時間チェック
    const reservationHour = reservationDateTime.getHours();
    if (reservationHour < BUSINESS_HOURS.START || reservationHour >= BUSINESS_HOURS.END) {
       return { success: false, message: '選択された時間は営業時間外です。' };
    }

    // --- 空き状況再チェック（重要：競合回避）---
    const reservationsSheet = SpreadsheetApp.openById(SPREADSHEET_ID).getSheetByName(SHEET_NAMES.RESERVATIONS);
    if (!reservationsSheet) {
      return { success: false, message: 'システムエラーが発生しました。予約シートが見つかりません。' };
    }
    
    const data = reservationsSheet.getDataRange().getValues();
    let currentReservationsAtTime = 0;
    for (let i = 1; i < data.length; i++) {
      // data[i][6] は予約日時, data[i][10] はキャンセル列
      const existingReservationTime = new Date(data[i][6]);
      const isCancelled = data[i][10]; // キャンセルフラグの値を取得
      if (!isCancelled && 
          existingReservationTime.getFullYear() === reservationDateTime.getFullYear() &&
          existingReservationTime.getMonth() === reservationDateTime.getMonth() &&
          existingReservationTime.getDate() === reservationDateTime.getDate() &&
          existingReservationTime.getHours() === reservationDateTime.getHours() &&
          existingReservationTime.getMinutes() === reservationDateTime.getMinutes()) {
        currentReservationsAtTime++;
      }
    }

    if (currentReservationsAtTime >= BUSINESS_HOURS.MAX_SLOTS) {
      console.warn(`予約競合発生: ${reservationData.date} ${reservationData.time}`);
      return { success: false, message: '申し訳ありません、選択された時間枠は直前に埋まってしまいました。別の日時を選択してください。' };
    }

    // --- 予約処理実行 ---
    // 予約ID生成 (よりユニークにするためランダム文字列追加)
    const reservationId = Utilities.formatDate(now, 'GMT+9', 'yyyyMMddHHmmss') + Math.random().toString(36).substring(2, 8);
    const endTime = new Date(reservationDateTime.getTime() + BUSINESS_HOURS.DURATION * 60 * 1000);
    const creationTime = now;

    // スプレッドシートに追記
    reservationsSheet.appendRow([
      reservationId,          // 予約ID [0]
      reservationData.userId, // UID [1]
      userInfo.name,          // 氏名 [2]
      userInfo.phone,         // 電話番号 [3]
      reservationData.menu,   // メニューID [4]
      reservationData.staff,  // スタッフID [5]
      reservationDateTime,    // 予約日時 [6]
      endTime,                // 終了時間 [7]
      creationTime,           // 予約作成日時 [8]
      false,                  // リマインド送信済み [9]
      false                   // キャンセル [10]
    ]);
    console.log(`スプレッドシートに予約追加: ID=${reservationId}`);

    // Googleカレンダーに登録
    try {
      const calendar = CalendarApp.getCalendarById(CALENDAR_ID);
      if (calendar) {
        const menu = MENU_PLANS.find(m => m.id === reservationData.menu) || { name: reservationData.menu };
        const staff = STAFF_MEMBERS.find(s => s.id === reservationData.staff) || { name: reservationData.staff };
        const eventTitle = `${userInfo.name}様 / ${menu.name} (${staff.name})`;
        const eventDescription = `予約ID: ${reservationId}\nLINE UID: ${reservationData.userId}\n電話番号: ${userInfo.phone}\nメニュー: ${menu.name}\n担当: ${staff.name}`;
        calendar.createEvent(eventTitle, reservationDateTime, endTime, { description: eventDescription });
        console.log(`Googleカレンダーにイベント追加: ${eventTitle}`);
      } else {
        console.error(`カレンダーが見つかりません (ID: ${CALENDAR_ID})`);
      }
    } catch (calendarError) {
      console.error(`カレンダー登録エラー (予約ID: ${reservationId}):`, calendarError, calendarError.stack);
      // カレンダー登録失敗は予約自体は成功とするが、ログには残す
    }

    // LINEで予約完了通知
    try {
       const menu = MENU_PLANS.find(m => m.id === reservationData.menu) || { name: reservationData.menu };
       const staff = STAFF_MEMBERS.find(s => s.id === reservationData.staff) || { name: reservationData.staff };
       const message = `ご予約ありがとうございます。\n\n` +
                       `日時: ${formatDate(reservationDateTime)} ${reservationData.time}\n` +
                       `メニュー: ${menu.name}\n` +
                       `担当: ${staff.name}\n\n` +
                       `予約ID: ${reservationId}\n`+
                       `前日に確認メッセージをお送りします。\n` +
                       `ご来店をお待ちしております。`;
       sendLineMessage(reservationData.userId, message);
    } catch (lineError) {
       console.error(`予約完了LINE通知エラー (予約ID: ${reservationId}):`, lineError, lineError.stack);
       // LINE通知失敗も予約自体は成功とする
    }


    // 成功レスポンス
    const menu = MENU_PLANS.find(m => m.id === reservationData.menu) || { name: reservationData.menu };
    const staff = STAFF_MEMBERS.find(s => s.id === reservationData.staff) || { name: reservationData.staff };
    return {
      success: true,
      message: '予約が完了しました。',
      reservationInfo: { // クライアント側での表示用に情報を返す
        id: reservationId,
        date: reservationData.date,
        time: reservationData.time,
        menu: menu.name,
        staff: staff.name
      }
    };

  } catch (error) {
    console.error('createReservationでエラー:', error, error.stack);
    return { success: false, message: '予約処理中に予期せぬエラーが発生しました。' };
  } finally {
    try {
      if (lock.hasLock()) {
        lock.releaseLock();
      }
    } catch (lockError) {
      console.error('ロック解放エラー:', lockError);
    }
  }
}


/**
 * 予約をキャンセルする (クライアントサイドJSまたはLINEメッセージから呼び出される)
 * @param {string} reservationId - キャンセルする予約ID
 * @param {string} userId - 操作を行うユーザーのLINEユーザーID
 * @return {object} - { success: boolean, message: string }
 */
function cancelReservation(reservationId, userId) {
  console.log(`cancelReservation呼び出し: ID=${reservationId}, User=${userId}`);
  if (!reservationId || !userId) {
    return { success: false, message: '予約IDまたはユーザーIDが指定されていません。' };
  }

  const lock = LockService.getScriptLock();
  try {
    lock.waitLock(15000); // 最大15秒待機

    const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
    const sheet = ss.getSheetByName(SHEET_NAMES.RESERVATIONS);
    if (!sheet) {
      console.error('予約情報シートが見つかりません。');
      return { success: false, message: 'システムエラーが発生しました。(Sheet not found)' };
    }
    const data = sheet.getDataRange().getValues();
    let reservationFound = false;
    let reservationDetails = {};

    // ヘッダーを除いて検索 (インデックス1から)
    for (let i = 1; i < data.length; i++) {
      // data[i][0]は予約ID, data[i][1]はUID, data[i][10]はキャンセル列
      if (data[i][0] === reservationId) {
        // ユーザーIDが一致するか、または管理者が操作する場合などを考慮（今回はユーザーID一致のみ）
        if (data[i][1] === userId) {
          reservationFound = true;
           // すでにキャンセル済みかチェック
           if (data[i][10] === true) {
               console.log(`予約ID ${reservationId} は既にキャンセルされています。`);
               return { success: false, message: 'この予約は既にキャンセルされています。' };
           }
           // 過去の予約はキャンセルできないようにする（任意）
           const reservationDateTime = new Date(data[i][6]);
           if (reservationDateTime < new Date()) {
               console.log(`過去の予約 (${reservationId}) のキャンセル試行。`);
               return { success: false, message: '過去の予約をキャンセルすることはできません。' };
           }

          // キャンセル処理実行
          sheet.getRange(i + 1, 11).setValue(true); // キャンセル列 (11番目=K列) に true を設定
          sheet.getRange(i + 1, 12).setValue(new Date()); // キャンセル日時列 (12番目=L列) を追加する場合
          console.log(`スプレッドシートで予約キャンセル: ID=${reservationId}`);

          // 予約詳細を保持
          reservationDetails = {
             date: formatDate(reservationDateTime),
             time: `${String(reservationDateTime.getHours()).padStart(2, '0')}:${String(reservationDateTime.getMinutes()).padStart(2, '0')}`,
             menu: data[i][4], // メニューID
             staff: data[i][5] // スタッフID
          };


          // Googleカレンダーからイベント削除
          try {
            const calendar = CalendarApp.getCalendarById(CALENDAR_ID);
            if (calendar) {
              // イベント検索: タイトルや説明に予約IDが含まれるものを探す
              const events = calendar.getEvents(reservationDateTime, new Date(reservationDateTime.getTime() + 2 * 60 * 60 * 1000), { search: reservationId }); // 予約時刻周辺で検索
              if (events.length > 0) {
                events[0].deleteEvent(); // 最初に見つかったものを削除 (IDで完全一致が望ましい)
                console.log(`Googleカレンダーからイベント削除: ID=${reservationId}`);
              } else {
                console.warn(`カレンダーイベントが見つかりません: ID=${reservationId}`);
              }
            } else {
              console.error(`カレンダーが見つかりません (ID: ${CALENDAR_ID})`);
            }
          } catch (calendarError) {
            console.error(`カレンダー削除エラー (予約ID: ${reservationId}):`, calendarError, calendarError.stack);
            // カレンダー削除失敗はキャンセル自体は成功とする
          }

          // LINEでキャンセル完了通知
          try {
             const menu = MENU_PLANS.find(m => m.id === reservationDetails.menu) || { name: reservationDetails.menu };
             const staff = STAFF_MEMBERS.find(s => s.id === reservationDetails.staff) || { name: reservationDetails.staff };
             const message = `以下の予約をキャンセルしました。\n\n` +
                             `日時: ${reservationDetails.date} ${reservationDetails.time}\n` +
                             `メニュー: ${menu.name}\n` +
                             `担当: ${staff.name}\n` +
                             `予約ID: ${reservationId}`;
             sendLineMessage(userId, message);
          } catch (lineError) {
             console.error(`キャンセル完了LINE通知エラー (予約ID: ${reservationId}):`, lineError, lineError.stack);
          }


          return { success: true, message: '予約をキャンセルしました。' };
        } else {
          // 予約IDは存在するが、ユーザーIDが一致しない場合
          console.warn(`予約キャンセル権限なし: ID=${reservationId}, User=${userId}, Owner=${data[i][1]}`);
          return { success: false, message: '指定された予約をキャンセルする権限がありません。' };
        }
      }
    }

    // ループを抜けても見つからなかった場合
    if (!reservationFound) {
      console.log(`キャンセル対象の予約が見つかりません: ID=${reservationId}`);
      return { success: false, message: '指定された予約IDが見つかりません。' };
    }

  } catch (error) {
    console.error('cancelReservationでエラー:', error, error.stack);
    return { success: false, message: '予約キャンセル処理中に予期せぬエラーが発生しました。' };
  } finally {
    try {
      if (lock.hasLock()) {
        lock.releaseLock();
      }
    } catch (lockError) {
      console.error('ロック解放エラー:', lockError);
    }
  }
}


/**
 * 指定されたユーザーの有効な（キャンセルされておらず未来の）予約一覧を取得する
 * @param {string} userId - LINEユーザーID
 * @return {Array<object>} - 予約情報の配列
 */
function getUserReservations(userId) {
  console.log(`getUserReservations呼び出し: User=${userId}`);
  try {
    const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
    const sheet = ss.getSheetByName(SHEET_NAMES.RESERVATIONS);
    if (!sheet) {
      console.error('予約情報シートが見つかりません。');
      initializeSystem(); // シートがなければ初期化を試みる
      return [];
    }
    const data = sheet.getDataRange().getValues();
    const reservations = [];
    const now = new Date(); // 現在時刻

    // ヘッダー行(0)をスキップし、1行目からループ
    for (let i = 1; i < data.length; i++) {
      const row = data[i];
      // ユーザーIDが一致し、キャンセル列(10)がfalseまたは空であること
      if (row[1] === userId && (row[10] === false || row[10] === '')) {
        const reservationDateTime = new Date(row[6]); // 予約日時(6)
        // 未来の予約のみを対象とする
        if (reservationDateTime >= now) {
          reservations.push({
            id: row[0], // 予約ID(0)
            date: formatDate(reservationDateTime), // YYYY-MM-DD
            time: `${String(reservationDateTime.getHours()).padStart(2, '0')}:${String(reservationDateTime.getMinutes()).padStart(2, '0')}`, // HH:MM
            menu: row[4], // メニューID(4)
            staff: row[5], // スタッフID(5)
            // 必要であれば他の情報も追加
          });
        }
      }
    }

    // 日付順にソート (古い順)
    reservations.sort((a, b) => {
      const dateA = new Date(`${a.date}T${a.time}:00`);
      const dateB = new Date(`${b.date}T${b.time}:00`);
      return dateA - dateB;
    });

    console.log(`ユーザー (${userId}) の有効な予約 ${reservations.length} 件を取得`);
    return reservations;

  } catch (error) {
    console.error('getUserReservationsでエラー:', error, error.stack);
    return []; // エラー時は空配列を返す
  }
}

// ----------------------------------------
// ユーザー情報関連
// ----------------------------------------

/**
 * ユーザー情報をスプレッドシートから取得する
 * @param {string} userId - LINEユーザーID
 * @return {object|null} - ユーザー情報オブジェクト、見つからない場合はnull
 */
function getUserInfo(userId) {
  console.log(`getUserInfo呼び出し: User=${userId}`);
  if (!userId) return null;

  try {
    const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
    const sheet = ss.getSheetByName(SHEET_NAMES.USERS);
    if (!sheet) {
      console.error('ユーザー情報シートが見つかりません。');
      initializeSystem(); // シートがなければ初期化を試みる
      return null;
    }
    const data = sheet.getDataRange().getValues();

    // ヘッダー行(0)をスキップし、1行目からループ
    for (let i = 1; i < data.length; i++) {
      if (data[i][0] === userId) { // UID列(0)で比較
        console.log(`ユーザー情報発見: ${userId}`);
        return {
          userId: data[i][0],
          name: data[i][1],
          phone: data[i][2],
          email: data[i][3],
          gender: data[i][4],
          birthdate: data[i][5] ? formatDate(new Date(data[i][5])) : null // 日付形式で返す
        };
      }
    }
    console.log(`ユーザー情報見つからず: ${userId}`);
    return null;
  } catch (error) {
    console.error('getUserInfoでエラー:', error, error.stack);
    return null;
  }
}

/**
 * 新規ユーザーを登録する (クライアントサイドJSから呼び出される)
 * @param {object} userData - ユーザー情報 (userId, name, phone, email, gender, birthdate)
 * @return {object} - { success: boolean, message: string }
 */
function registerUser(userData) {
  console.log('registerUser呼び出し:', JSON.stringify(userData));
  if (!userData || !userData.userId || !userData.name || !userData.phone || !userData.email || !userData.gender || !userData.birthdate) {
    return { success: false, message: '登録情報が不足しています。' };
  }

  const lock = LockService.getScriptLock();
  try {
    lock.waitLock(10000); // 最大10秒待機

    // 既存ユーザーチェック
    if (getUserInfo(userData.userId)) {
      console.log(`ユーザー (${userData.userId}) は既に登録済みです。`);
      // 既存ユーザーの場合は成功として扱い、予約フォームへ遷移させるメッセージを返す
      return { success: true, message: 'ユーザー情報は既に登録されています。予約ページへ進みます。' };
    }

    const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
    const sheet = ss.getSheetByName(SHEET_NAMES.USERS);
    if (!sheet) {
      console.error('ユーザー情報シートが見つかりません。');
      initializeSystem(); // 初期化試行
      // 再度シート取得を試みる
      const newSheet = ss.getSheetByName(SHEET_NAMES.USERS);
      if (!newSheet) {
          return { success: false, message: 'システムエラーが発生しました。(User sheet creation failed)' };
      }
      // 新しいシートを使用する
      const registrationTime = new Date();
      newSheet.appendRow([
        userData.userId,
        userData.name,
        userData.phone,
        userData.email,
        userData.gender,
        new Date(userData.birthdate), // Dateオブジェクトとして保存
        registrationTime
      ]);
    } else {
      const registrationTime = new Date();
      // スプレッドシートに追記
      sheet.appendRow([
        userData.userId,
        userData.name,
        userData.phone,
        userData.email,
        userData.gender,
        new Date(userData.birthdate), // Dateオブジェクトとして保存
        registrationTime
      ]);
    }

    console.log(`ユーザー登録完了: ${userData.userId}, ${userData.name}`);
    return { success: true, message: '会員登録が完了しました。' };

  } catch (error) {
    console.error('registerUserでエラー:', error, error.stack);
    return { success: false, message: 'ユーザー登録中に予期せぬエラーが発生しました。' };
  } finally {
    try {
      if (lock.hasLock()) {
        lock.releaseLock();
      }
    } catch (lockError) {
      console.error('ロック解放エラー:', lockError);
    }
  }
}

// ----------------------------------------
// リマインダー機能
// ----------------------------------------

/**
 * 予約前日にリマインドメッセージを送信する（トリガーで定期実行）
 */
function sendReminders() {
  console.log('sendReminders実行開始');
  try {
    const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
    const sheet = ss.getSheetByName(SHEET_NAMES.RESERVATIONS);
    if (!sheet) {
      console.error('リマインダー: 予約情報シートが見つかりません。');
      return;
    }
    const data = sheet.getDataRange().getValues();
    const now = new Date();
    const tomorrowStart = new Date(now);
    tomorrowStart.setDate(now.getDate() + 1);
    tomorrowStart.setHours(0, 0, 0, 0); // 明日の午前0時
    const tomorrowEnd = new Date(tomorrowStart);
    tomorrowEnd.setDate(tomorrowStart.getDate() + 1); // 明後日の午前0時

    let reminderCount = 0;
    // ヘッダー行(0)をスキップ
    for (let i = 1; i < data.length; i++) {
      const row = data[i];
      const isCancelled = row[10]; // キャンセル列(10)
      const reminderSent = row[9]; // リマインド送信済み列(9)
      const reservationDateTime = new Date(row[6]); // 予約日時(6)

      // キャンセルされておらず、リマインド未送信で、予約が明日である場合
      if (!isCancelled && !reminderSent && reservationDateTime >= tomorrowStart && reservationDateTime < tomorrowEnd) {
        const userId = row[1];
        const userName = row[2];
        const menuId = row[4];
        const staffId = row[5];
        const timeStr = `${String(reservationDateTime.getHours()).padStart(2, '0')}:${String(reservationDateTime.getMinutes()).padStart(2, '0')}`;

        const menu = MENU_PLANS.find(m => m.id === menuId) || { name: menuId };
        const staff = STAFF_MEMBERS.find(s => s.id === staffId) || { name: staffId };

        const message = `【予約リマインダー】\n\n` +
                        `${userName}様\n\n` +
                        `明日のご予約についてお知らせします。\n\n` +
                        `日時: ${formatDate(reservationDateTime)} ${timeStr}\n` +
                        `メニュー: ${menu.name}\n` +
                        `担当: ${staff.name}\n\n` +
                        `ご来店をお待ちしております。\n` +
                        `ご都合が悪くなった場合は、お早めに「予約確認」からキャンセルをお願いします。`;

        // LINE送信試行
        const success = sendLineMessage(userId, message);

        if (success) {
          // 送信成功したらスプレッドシートのフラグを更新
          sheet.getRange(i + 1, 10).setValue(true); // リマインド送信済み列(10)にtrueを設定
          reminderCount++;
          console.log(`リマインド送信成功: User=${userId}, ReservationID=${row[0]}`);
        } else {
          console.error(`リマインド送信失敗: User=${userId}, ReservationID=${row[0]}`);
          // 失敗した場合の再試行ロジックや通知などを検討
        }
         // API制限回避のため少し待機
         Utilities.sleep(300);
      }
    }
    console.log(`sendReminders実行完了: ${reminderCount}件送信`);
  } catch (error) {
    console.error('sendRemindersでエラー:', error, error.stack);
  }
}

/**
 * sendReminders関数を実行するための時間ベースのトリガーを設定する
 */
function setupRemindTrigger() {
  // 既存のsendRemindersトリガーを削除
  const triggers = ScriptApp.getProjectTriggers();
  triggers.forEach(trigger => {
    if (trigger.getHandlerFunction() === 'sendReminders') {
      ScriptApp.deleteTrigger(trigger);
      console.log('既存のリマインダートリガーを削除しました。');
    }
  });

  // 毎日指定した時刻（例: 午前9時）に実行するトリガーを作成
  ScriptApp.newTrigger('sendReminders')
    .timeBased()
    .everyDays(1)
    .atHour(9) // 例: 毎日午前9時に実行
    .inTimezone('Asia/Tokyo') // タイムゾーンを指定
    .create();
  console.log('新しいリマインダートリガー（毎日午前9時）を設定しました。');
}


// ----------------------------------------
// 初期化・ヘルパー関数
// ----------------------------------------

/**
 * システム初期化（スプレッドシートのシートとヘッダーを作成）
 */
function initializeSystem() {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet() || SpreadsheetApp.openById(SPREADSHEET_ID); // アクティブまたはIDで開く
    let sheetCreated = false;

    // ユーザー情報シート
    if (!ss.getSheetByName(SHEET_NAMES.USERS)) {
      const usersSheet = ss.insertSheet(SHEET_NAMES.USERS);
      usersSheet.appendRow(['UID', '氏名', '電話番号', 'メールアドレス', '性別', '生年月日', '登録日時']);
      usersSheet.setFrozenRows(1);
      console.log(`${SHEET_NAMES.USERS}シートを作成しました。`);
      sheetCreated = true;
    }

    // 予約情報シート
    if (!ss.getSheetByName(SHEET_NAMES.RESERVATIONS)) {
      const reservationsSheet = ss.insertSheet(SHEET_NAMES.RESERVATIONS);
      reservationsSheet.appendRow(['予約ID', 'UID', '氏名', '電話番号', 'メニューID', 'スタッフID', '予約日時', '終了日時', '予約作成日時', 'リマインド送信済', 'キャンセル済', 'キャンセル日時']);
      reservationsSheet.setFrozenRows(1);
      // 日付列の書式設定 (任意)
      reservationsSheet.getRange('G:H').setNumberFormat('yyyy/mm/dd hh:mm');
      reservationsSheet.getRange('I:I').setNumberFormat('yyyy/mm/dd hh:mm:ss');
      reservationsSheet.getRange('L:L').setNumberFormat('yyyy/mm/dd hh:mm:ss');
      console.log(`${SHEET_NAMES.RESERVATIONS}シートを作成しました。`);
      sheetCreated = true;
    }

    // 設定シート (現在は未使用だが、構造として残す)
    if (!ss.getSheetByName(SHEET_NAMES.SETTINGS)) {
      const settingsSheet = ss.insertSheet(SHEET_NAMES.SETTINGS);
      settingsSheet.appendRow(['設定項目', '値']);
      settingsSheet.appendRow(['定休日 (曜日番号)', CLOSED_DAYS.join(',')]); // 例: 1 (月曜)
      settingsSheet.appendRow(['予約開始日数前', MIN_DAYS_AHEAD]);
      settingsSheet.appendRow(['予約可能日数', DAYS_AHEAD]);
      settingsSheet.setFrozenRows(1);
      console.log(`${SHEET_NAMES.SETTINGS}シートを作成しました。`);
      sheetCreated = true;
    }

    if (sheetCreated) {
       SpreadsheetApp.flush(); // 変更を即時反映
       console.log('システム初期化完了。');
    }


  } catch (error) {
    console.error('システム初期化中にエラーが発生しました:', error, error.stack);
    // ここでエラーをthrowするか、falseを返すなど、呼び出し元で処理できるようにする
    throw new Error('システム初期化に失敗しました: ' + error.message);
  }
}

/**
 * 日付オブジェクトをYYYY-MM-DD 形式の文字列にフォーマットする
 * @param {Date} date - フォーマットする日付オブジェクト
 * @return {string} - フォーマットされた日付文字列
 */
function formatDate(date) {
  if (!date || !(date instanceof Date) || isNaN(date.getTime())) {
    // console.warn('formatDate: 無効な日付が渡されました:', date);
    return ''; // 無効な日付の場合は空文字を返す
  }
  try {
    // UTC基準ではなく、スクリプトのタイムゾーン（通常は日本のタイムゾーン）でフォーマット
    return Utilities.formatDate(date, Session.getScriptTimeZone(), 'yyyy-MM-dd');
  } catch (error) {
     console.error('formatDateでエラー:', error);
     // フォールバックとして手動でフォーマット
     const year = date.getFullYear();
     const month = String(date.getMonth() + 1).padStart(2, '0');
     const day = String(date.getDate()).padStart(2, '0');
     return `${year}-${month}-${day}`;
  }
}


/**
 * スプレッドシートから有効な（キャンセルされていない）全予約データを取得する
 * （キャッシュ利用を検討する箇所）
 * @return {Array<object>} - 有効な予約データの配列 {id, userId, startTime, endTime, ...}
 */
function getAllValidReservations() {
  // ここでキャッシュ（CacheService）を利用すると、頻繁な読み込みを避けられる
  // const cache = CacheService.getScriptCache();
  // const cachedData = cache.get('allValidReservations');
  // if (cachedData) {
  //   console.log('予約データをキャッシュから取得');
  //   return JSON.parse(cachedData).map(r => ({ ...r, startTime: new Date(r.startTime), endTime: new Date(r.endTime) }));
  // }

  console.log('スプレッドシートから全予約データを読み込み中...');
  try {
    const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
    const sheet = ss.getSheetByName(SHEET_NAMES.RESERVATIONS);
    if (!sheet) return [];
    const data = sheet.getDataRange().getValues();
    const reservations = [];
    const now = new Date();

    // ヘッダー行(0)をスキップ
    for (let i = 1; i < data.length; i++) {
      const row = data[i];
      const isCancelled = row[10]; // キャンセル列(10)

      // キャンセルされておらず、データが不完全でない場合
      if (!isCancelled && row[0] && row[1] && row[6] && row[7]) {
         const startTime = new Date(row[6]);
         const endTime = new Date(row[7]);
         // 日付オブジェクトが有効かチェック
         if (!isNaN(startTime.getTime()) && !isNaN(endTime.getTime())) {
            // 過去の予約も含めて返す（getWeeklyAvailability側でフィルタリングするため）
             reservations.push({
               id: row[0],
               userId: row[1],
               startTime: startTime,
               endTime: endTime,
               // 他に必要な情報があれば追加
             });
         } else {
            console.warn(`予約データの日付が無効です。スキップします。 Row=${i+1}, Start=${row[6]}, End=${row[7]}`);
         }
      }
    }
    console.log(`有効な予約 ${reservations.length} 件をシートから取得`);

    // キャッシュに保存 (例: 10分間)
    // cache.put('allValidReservations', JSON.stringify(reservations), 600);

    return reservations;
  } catch (error) {
    console.error('getAllValidReservationsでエラー:', error, error.stack);
    return [];
  }
}


// ----------------------------------------
// セットアップ・テスト用関数
// ----------------------------------------

/**
 * システム全体のセットアップを実行する（手動実行用）
 * スプレッドシート初期化とトリガー設定を行う
 */
function setupSystem() {
  try {
    console.log('システムセットアップ開始...');
    initializeSystem(); // スプレッドシート初期化
    setupRemindTrigger(); // リマインダートリガー設定
    console.log('システムセットアップ完了。スクリプトプロパティ（LINE_ACCESS_TOKEN, CALENDAR_ID, SPREADSHEET_ID）を設定してください。');
    // スクリプトプロパティ設定を促すメッセージ
    SpreadsheetApp.getUi().alert('システムセットアップ完了。ファイル > プロジェクトの設定 > スクリプト プロパティ で、LINE_ACCESS_TOKEN, CALENDAR_ID, SPREADSHEET_ID を設定してください。');
  } catch (error) {
    console.error('setupSystemでエラー:', error, error.stack);
     SpreadsheetApp.getUi().alert('システムセットアップ中にエラーが発生しました。\n' + error.message);
  }
}

/**
 * Webアプリの動作テスト用関数 (doGetの代わり)
 */
function testDoGet() {
  // テスト用のユーザーIDを指定
  const testUserId = 'Uxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx'; // 実際のLINEユーザーIDに置き換えるか、テスト用IDを使用
  const e = { parameter: { userId: testUserId } };
  // doGetを実行し、結果をログに出力（HTMLは直接表示できない）
  const htmlOutput = doGet(e);
  console.log('テスト用doGet実行完了。HTMLタイトル:', htmlOutput.getTitle());
  // Logger.log(htmlOutput.getContent()); // HTMLコンテンツをログに出力（非常に長くなる可能性あり）
}

/**
 * 週間空き状況取得のテスト用関数
 */
function testWeeklyAvailability() {
  const today = new Date();
  const startDateStr = formatDate(today); // 今日の日付から始まる週
  console.log(`testWeeklyAvailability実行: ${startDateStr}`);
  const result = getWeeklyAvailability(startDateStr);
  console.log('週間予約状況テスト結果:', JSON.stringify(result, null, 2));
}

/**
 * ユーザー予約一覧取得のテスト用関数
 */
function testGetUserReservations() {
   const testUserId = 'Uxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx'; // 予約を持つユーザーIDを指定
   console.log(`testGetUserReservations実行: User=${testUserId}`);
   const reservations = getUserReservations(testUserId);
   console.log('ユーザー予約一覧テスト結果:', JSON.stringify(reservations, null, 2));
}

/**
* 予約作成テスト用関数
*/
function testCreateReservation() {
   const testUserId = 'Uxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx'; // 登録済みのユーザーID
   // 未来の予約可能な日時を指定
   const testDate = new Date();
   testDate.setDate(testDate.getDate() + 5); // 5日後
   testDate.setHours(14, 30, 0, 0); // 14:30

   const reservationData = {
       userId: testUserId,
       menu: 'A', // 存在するメニューID
       staff: 'sato', // 存在するスタッフID
       date: formatDate(testDate),
       time: `${String(testDate.getHours()).padStart(2, '0')}:${String(testDate.getMinutes()).padStart(2, '0')}`
   };
   console.log('testCreateReservation実行:', reservationData);
   const result = createReservation(reservationData);
   console.log('予約作成テスト結果:', JSON.stringify(result, null, 2));
}

/**
* 予約キャンセルテスト用関数
*/
function testCancelReservation() {
   const testUserId = 'Uxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx'; // 予約を持つユーザーID
   const testReservationId = 'YYYYMMDDHHMMSSabcdef'; // キャンセルしたい予約のIDを指定

   if (testReservationId === 'YYYYMMDDHHMMSSabcdef') {
      console.warn('testCancelReservation: testReservationId を実際の予約IDに置き換えてください。');
      return;
   }

   console.log(`testCancelReservation実行: ID=${testReservationId}, User=${testUserId}`);
   const result = cancelReservation(testReservationId, testUserId);
   console.log('予約キャンセルテスト結果:', JSON.stringify(result, null, 2));
}

